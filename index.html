<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E.C.A. - 감정세포 배양 프로토콜</title>

    <link rel="preload" href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Heavy.woff2" as="font" type="font/woff2" crossorigin>
    
    <link href="https://cdn.jsdelivr.net/gh/naver/d2codingfont/dist/d2coding.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- QZ Tray 라이브러리 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es6-promise/4.2.8/es6-promise.auto.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qz-tray@2.2/qz-tray.js"></script>
    
    <style>
        /* OnulDamso 폰트 정의 추가 */
        @font-face {
            font-family: 'OnulDamso';
            font-weight: 400; /* Regular */
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Regular.woff2') format('woff2');
        }
        @font-face {
            font-family: 'OnulDamso';
            font-weight: 900; /* Heavy (Bold) */
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Heavy.woff2') format('woff2');
        }

        :root {
            --main-bg: #F9F9F9; 
            --page-bg: #FFFFFF;
            --main-text: #111111;
            --border-color: #DDDDDD; 
            --border-focus: #000000;
            --gray-mid: #999;
            --gray-light: #F0F0F0;
            --button-hover-bg: #111111;
            --button-hover-text: #ffffff;
            font-family: 'OnulDamso', monospace;
            font-size: 14px;
        }
        :root {
            --panel-width: 80px;
            --animation-speed: 0.4s;
            --border-width: 1.5px;
        }
        .font-thin { font-family: 'OnulDamso', monospace; font-weight: normal; }
        .font-thick { font-family: 'OnulDamso', monospace; font-weight: bold; }
        * { box-sizing: border-box; }
        body {
            transition: background 0.3s, color 0.3s;
            background-color: var(--main-bg); 
            color: var(--main-text);
            margin: 0;
            overflow: hidden; 
            height: 100vh;
        }
        .main-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: none;
        }
        .panel {
            position: absolute;
            top: 0;
            height: 100%;
            width: var(--panel-width);
            background-color: var(--page-bg);
            border: var(--border-width) solid var(--border-focus);
            border-top: none;
            border-bottom: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            transition: left var(--animation-speed) ease-in-out, 
                        background-color var(--animation-speed) ease-in-out, 
                        color var(--animation-speed) ease-in-out;
            margin-left: 0;
            color: var(--main-text);
        }
        #panel-result { left: 0; margin-left: 0; }
        #panel-sensitivity { left: var(--panel-width); margin-left: calc(var(--border-width) * -1); }
        #panel-survey { left: 0; margin-left: 0; } 
        .content-area {
            position: absolute;
            top: 0;
            left: 0; 
            height: 100%;
            width: 100vw; 
            z-index: 10;
            overflow: hidden;
            border: none;
        }
        .content-block {
            width: 100vw;
            height: 100%;
            display: block !important; 
            background-color: var(--page-bg); 
            border: none; 
            position: absolute;
            top: 0;
            left: 100vw; 
            transition: left var(--animation-speed) ease-in-out, width var(--animation-speed) ease-in-out;
        }
        #content-survey { z-index: 13; }
        #content-sensitivity { z-index: 14; }
        #content-result { z-index: 15; }
        body.survey-active #panel-result { left: 0; margin-left: 0; }
        body.survey-active #panel-sensitivity { left: var(--panel-width); margin-left: calc(var(--border-width) * -1); }
        body.survey-active #panel-survey { left: calc(100vw - var(--panel-width)); margin-left: 0; }
        body.survey-active #panel-survey { background-color: var(--border-focus); color: var(--page-bg); }
        body.survey-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
        body.survey-active #content-survey { left: calc(var(--panel-width) * 2); }
        body.survey-active #content-sensitivity { left: -100vw; }
        body.survey-active #content-result { left: -100vw; }
        body.sensitivity-active #panel-result { left: 0; margin-left: 0; }
        body.sensitivity-active #panel-sensitivity { left: calc(100vw - var(--panel-width) * 2); margin-left: 0; } 
        body.sensitivity-active #panel-survey { left: calc(100vw - var(--panel-width)); margin-left: calc(var(--border-width) * -1); } 
        body.sensitivity-active #panel-sensitivity { background-color: var(--border-focus); color: var(--page-bg); }
        body.sensitivity-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
        body.sensitivity-active #content-survey { left: calc(var(--panel-width) * 2); } 
        body.sensitivity-active #content-sensitivity { left: var(--panel-width); }
        body.sensitivity-active #content-result { left: -100vw; }
        body.result-active #panel-result { left: calc(100vw - var(--panel-width) * 3); margin-left: 0; } 
        body.result-active #panel-sensitivity { left: calc(100vw - var(--panel-width) * 2); margin-left: calc(var(--border-width) * -1); } 
        body.result-active #panel-survey { left: calc(100vw - var(--panel-width)); margin-left: calc(var(--border-width) * -1); } 
        body.result-active #panel-result { background-color: var(--border-focus); color: var(--page-bg); }
        body.result-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
        body.result-active #content-survey { left: calc(var(--panel-width) * 2); }
        body.result-active #content-sensitivity { left: var(--panel-width); }
        body.result-active #content-result { left: 0; }
        .panel-content-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; writing-mode: vertical-rl; transform: rotate(180deg); position: relative; overflow: hidden; color: inherit; }
        .panel-archive-title { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); font-size: 0.8em; line-height: 1.4; text-align: center; opacity: 0.7; }
        .panel-archive-title span { display: block; }
        .panel-number { margin: 0; font-size: 1.2em; }
        .panel-main-title { margin: 0; margin-top: 8px; font-size: 1.5em; letter-spacing: 2px; }
        .fullscreen-container { display: flex; align-items: center; justify-content: center; height: 100%; padding: 20px; box-sizing: border-box; }
        .page-container { text-align: center; width: 100%; border: 1.5px solid var(--border-color); padding: 30px 40px 40px; position: relative; background-color: var(--page-bg); box-shadow: 0 4px 12px rgba(0,0,0,0.05); z-index: 5; }
        #step1-access .page-container { max-width: 480px;  } 
        .container-header { display: flex; justify-content: space-between; padding-bottom: 10px; margin-bottom: 25px; border-bottom: 1.5px solid var(--border-color); font-size: 1.05rem; opacity: 0.6; }
        #main-logo {
            width: 140px;
            height: auto;
            margin-bottom: 25px;
            position: relative;
            top: 10px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        @keyframes flicker { 0%, 100% { opacity: 1; text-shadow: 0 0 2px currentColor; } 50% { opacity: 0.7; text-shadow: none; } }
        #terminal-output { height: 100px; padding: 10px; font-size: 0.95rem; text-align: left; margin-top: 40px; margin-bottom: 20px; white-space: pre-wrap; background-color: var(--gray-light); border-bottom: 1.5px solid var(--border-color); }
        .input-line { display: flex; align-items: center; padding: 12px 0px; border-bottom: 1.5px solid var(--border-color); }
        .input-line:focus-within { border-color: var(--border-focus); }
        .input-line label { margin-right: 8px; font-weight: bold; font-size: 1rem; }
        #guest-id { background: none; border: none; outline: none; color: inherit; flex: 1; font-size: 1rem; }
        button { font-family: inherit; background: none; border: 1px solid currentColor; color: inherit; padding: 12px 20px; width: 100%; margin-top: 20px; cursor: pointer; transition: all 0.2s ease; border-radius: 4px; }
        button:hover { background: var(--button-hover-bg); color: var(--button-hover-text); }
        button:disabled { opacity: 0.5; cursor: not-allowed; background: var(--gray-light) !important; color: var(--gray-mid) !important; border-color: var(--gray-mid) !important; }

        #step2-protocol, #step3-culturing { justify-content: center; align-items: center; position: relative; overflow: hidden; }
        .protocol-page, .culturing-page { 
            border: none;
            background: transparent;
            box-shadow: none;
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .content-wrapper {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            padding: 30px 40px;
            background-color: transparent; 
            border: 1.5px solid transparent;
            backdrop-filter: none; 
            -webkit-backdrop-filter: none; 
        }
        .background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; 
            pointer-events: none;
        }

        #progress-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.1); margin-bottom: 30px; border-radius: 4px; overflow: hidden; }
        #progress-indicator { width: 0%; height: 100%; background: currentColor; transition: width 0.4s ease; }
        
        .navigation-buttons { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 15px; 
        }
        .nav-button { 
            width: auto; 
            padding: 8px 15px; 
            margin-top: 0; 
            font-size: 1.2rem; 
            font-weight: bold;
        }

        /* [수정됨] 네비게이션 버튼(다음/결과보기) 폰트 스타일을 선택지 버튼과 통일 */
#next-question, #prev-question {
    font-family: 'OnulDamso', monospace; /* 폰트 변경 */
    font-weight: 400; /* Regular 굵기 (Bold 아님) */
    font-size: 1.05rem; /* 선택지 버튼과 동일한 크기 */
}

        .nav-button:disabled { 
            opacity: 0.3; 
            cursor: not-allowed; 
        }
        
        .question-step { 
            display: none; 
            text-align: left; 
        }
        .main-question { font-size: 2rem; margin-bottom: 10px; font-weight: bold; }
        .sub-text { opacity: 0.6; margin-bottom: 25px; font-size: 1.05rem; }
        .choice-button { display: block; width: 100%; padding: 14px 20px; border: 1.5px solid #000000; background: transparent; color: var(--main-text--); text-align: left; font-size: 1.05rem; margin-bottom: 10px; transition: 0.2s; border-radius: 4px; }
        .choice-button:hover { background: var(--button-hover-bg); color: var(--button-hover-text); border-color: var(--button-hover-bg); }
        .choices.button-choices-scale { display: flex; justify-content: space-between; gap: 8px; margin-bottom: 20px; }
        .choices.button-choices-scale .choice-button { width: 18%; padding: 12px 8px; text-align: center; font-size: 1.05rem; margin-bottom: 0; }
        #step3-title { font-size: 2.0rem; text-align: center; margin-bottom: 20px; }
        .slider-wrapper { display: flex; align-items: center; justify-content: center; width: 100%; margin: 40px 0; }
        .slider-label { font-size: 0.9rem; opacity: 0.7; margin: 0 15px; }
        #sensitivity-slider { flex: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: var(--gray-light); border: 1px solid var(--main-text); outline: none; cursor: pointer; }
        #sensitivity-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 22px; height: 22px; background: var(--main-text); cursor: pointer; }
        #inject-button { position: relative; overflow: hidden; }
        #inject-progress-fill { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background-color: var(--button-hover-bg); transition: width 0.05s linear; z-index: 1; }
        #inject-text { position: relative; z-index: 2; }
        #inject-button.injecting #inject-text { color: var(--button-hover-text); }
        
        #step4-result { height: 100%; overflow-y: auto; position: relative; } 
        #step4-result.fullscreen-container { align-items: flex-start; padding-top: 40px; padding-bottom: 40px; }
        .result-page { max-width: 900px; text-align: left; padding: 25px 40px 40px; position: relative; overflow: visible; margin: 0 auto; border-color: transparent; box-shadow: none; }
        .result-title { font-size: 1.2rem; letter-spacing: 0.05em; margin-bottom: 5px; font-weight: bold; text-align: center; opacity: 0.8; }
        #result-cell-name-display { font-size: 2.5rem; font-weight: bold; margin-bottom: 25px; text-align: center; color: var(--border-focus); }
        .result-content { width: 100%; }
        .chart-container { 
            width: 100%; 
            max-width: 500px; 
            margin: 0 auto 30px auto; 
            padding: 15px; 
            border: 1.5px solid var(--border-color); 
            box-sizing: border-box; 
            display: flex;
            justify-content: center;
        }
        #result-cell-info, #result-analysis-data { width: 100%; text-align: left; line-height: 1.7; font-size: 1.05rem; }
        .result-info-heading { font-weight: bold; font-size: 1.05rem; color: var(--main-text); border-bottom: 1.5px solid var(--border-color); padding-bottom: 8px; margin-top: 25px; margin-bottom: 15px; }
        #result-cell-info p, #result-analysis-data p { margin: 10px 0; font-size: 1.05rem; }
        #result-analysis-data p strong { color: var(--border-focus); min-width: 250px; display: inline-block; }
        .final-message { opacity: 0.7; font-size: 0.9rem; margin-top: 25px; text-align: center; }
        .result-buttons { display: flex; gap: 15px; margin-top: 30px; }
        .result-buttons button { flex: 1; margin-top: 0; padding: 10px 20px; }

        @media (max-width: 1100px) { 
            body.survey-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
            body.sensitivity-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
            body.result-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
        }
        @media (max-width: 768px) {
            .choices.button-choices-scale { flex-direction: column; }
            .choices.button-choices-scale .choice-button { width: 100%; margin-bottom: 10px; }
             :root { --panel-width: 60px; }
            .panel h3 { font-size: 1.2em; }
            body.survey-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
            body.sensitivity-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
            body.result-active .content-block { width: calc(100vw - var(--panel-width) * 3); }
            #result-cell-name-display { font-size: 2rem; }
            .result-info-heading { font-size: 1.1rem; }
        }
        @media print { body { display: none; } }
    </style>
</head>
<body> 
    
    <section id="step1-access" class="fullscreen-container">
        <div class="page-container">
            <div class="container-header"><span>[ FILE: ECA_ACCESS.LOG ]</span></div>
            <svg id="main-logo" data-name="레이어_1" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 592.37 293.42">
              <defs>
                <style>
       .st0 {
  font-family: 'OnulDamso', monospace;
  font-size: 35.61px;
}
            
                  .st1 {
                    stroke-width: 5px;
                  }
            
                  .st1, .st2, .st3, .st4 {
                    fill: none;
                    stroke: #000;
                    stroke-miterlimit: 10;
                  }
            
                  .st2 {
                    stroke-width: 5px;
                  }
            
                  .st3 {
                    stroke-width: 5px;
                  }
            
                  .st4 {
                    stroke-width: 5px;
                  }
                </style>
              </defs>
              <path d="M592.37,23.25c0,4.49-1.58,8.31-4.74,11.47-3.16,3.16-6.98,4.73-11.47,4.73s-8.31-1.57-11.47-4.73-4.73-6.98-4.73-11.47,1.57-8.31,4.73-11.47c3.16-3.16,6.98-4.73,11.47-4.73s8.31,1.57,11.47,4.73,4.74,6.98,4.74,11.47ZM591.27,23.32c0-4.15-1.47-7.69-4.4-10.63-2.94-2.93-6.48-4.41-10.63-4.41s-7.69,1.47-10.63,4.41c-2.93,2.93-4.4,6.48-4.4,10.63s1.47,7.69,4.4,10.63c2.94,2.93,6.48,4.41,10.63,4.41s7.69-1.47,10.63-4.41c2.93-2.93,4.4-6.48,4.4-10.63ZM586.03,29.33c0,3.18-1.17,4.77-3.5,4.77-1.02,0-1.83-.35-2.42-1.07-.59-.71-.89-1.75-.89-3.11,0-2.11-.31-3.63-.91-4.55-.71-1.04-1.94-1.56-3.71-1.56h-1.64v8.05c0,.65.37.98,1.1.98h2.18v1.02h-9.57v-1.02h2.04c.87,0,1.31-.33,1.31-.98V15.39c0-.41-.1-.69-.29-.84-.19-.14-.53-.22-1.02-.22h-2.04v-1.05h10.63c2.04,0,3.63.46,4.78,1.37,1.16.91,1.73,2.16,1.73,3.73,0,1.26-.43,2.32-1.28,3.17-.58.58-1.35,1.02-2.29,1.31-.72.22-1.75.4-3.05.54,1.6.49,2.7,1.01,3.31,1.57.53.49.9,1.14,1.09,1.96.46,1.82.73,2.86.8,3.13.41,1.43.91,2.14,1.49,2.14.8,0,1.2-.96,1.2-2.87h.95ZM580.61,18.52c0-1.82-.49-3.02-1.46-3.6-.66-.39-1.93-.59-3.83-.59-.97,0-1.6.05-1.91.15-.3.1-.46.39-.46.87v7.35h2.44c3.47,0,5.2-1.4,5.2-4.19Z"/>
              <g>
                <path class="st1" d="M53.63,110.76c-.2,4.13,2.09,9.44,6.36,10.2,3.16.56,5.35-1.72,8.59-.74,2.05.62,2.28,1.87,3.51,2.85,6.06,4.85,29.41-2.26,38.06-7.72.84-.53,3.36-2.19,7.25-3.77,3.39-1.38,6.06-1.99,7.01-2.23,10.99-2.83,14.34-14.29,31.38-22.09,3.63-1.66,3.1-.97,5.85-2.34,8.87-4.43,16.8-12.85,18.49-21.74.54-2.83.2-4.48,1.81-7.45,2-3.69,4.44-4.72,7.12-7.85,3.87-4.52,4.41-8.97,4.94-13.4.8-6.61-.89-11.77-1.98-14.43-1.79-4.32-5.71-13.84-14.51-14.99-4.05-.53-5.1,1.23-11.2,1.67-9.12.65-11.49-2.95-19.92-4.08-10.91-1.46-26.02,1.99-34.07,8.96-3.73,3.22-5.39,6.72-11.68,9.2-4.76,1.88-6.64.99-9.02,2.93-4.39,3.57-.14,8.39-4.94,12.68-2.1,1.88-2.9.93-6.55,3.38-5.58,3.74-4.79,6.66-9.21,8.95-3.71,1.92-4.98.22-10.15,1.83-7.29,2.26-11.42,7.69-14.24,11.4-3.24,4.25-2.09,6.57-5.7,8.85-3.15,1.99-5.27,1.33-7.27,3.35-2.77,2.8.07,5.3-2.57,8.26-2.36,2.64-5.3,1.41-8.01,3.87-4.29,3.89.13,9.63-3.99,12.02-1.88,1.09-3.3.31-4.84,1.44-2.12,1.55-.07,4.66.28,8.5.32,3.54-.95,6.09-3.42,11.04-4.07,8.16-10.37,9.41-9.59,13.83.32,1.82,1.56,2.95,2.01,6.64.23,1.91.1,3.25.04,4.23-.19,3.27-.62,10.82,4.34,16.03,2.22,2.33,2.86,1.39,6.65,4.69,5.49,4.77,3.85,6.46,7.24,8.4,5.71,3.26,11.77-.72,20.41,2.59,3.95,1.52,2.72,2.37,6.81,4.28,12.36,5.79,30.52,1.29,35.41-2.02.41-.27,1.08-.78,2.23-1.21,4.31-1.6,8.91.32,9.53-.54.38-.52-1.36-1.2-1.09-1.96.55-1.56,7.5-.53,14.38-2.24,7.81-1.94,12.19-6.99,15.76-10.9,1.8-1.97,2.43-3.1,2.61-4.35.56-3.81-3.18-7.93-6.94-7.97-1.99-.02-3.44,1.1-4.63,1.84-7.36,4.58-14.58.86-29.78,3.39-9.81,1.63-11.19,3.91-19.52,3.95-4.37.02-9.1-.1-12.71-2.41-2.09-1.33-2.53-3.03-5.39-3.92-2.46-.77-3.88-.14-6.88-.28-3.4-.15-9.1-1.28-11.23-4.26-3.04-4.27,2.31-10.84,3.44-12.23,2.35-2.89,3.91-3.19,5.22-5.89,1.6-3.29.54-5.34.62-7.93.26-8.83,13.7-16.93,15.27-16.18.7.33-1.K-1.59,5.9Z"/>
                <path class="st2" d="M152.13,68.01c1.96-4.03,2.51-4.49,4.76-8.75,3.26-6.16,2.53-6,4.73-9.87,3.8-6.7,5.39-6.16,6.86-10.27,2.03-5.68,1.18-12.86-1.76-14.11-2-.85-3.26,1.77-7.66,1.86-4.16.09-5.22-2.21-7.99-1.61-3.3.71-4.05,4.44-6.97,8.42-3.79,5.15-7.07,5.06-13.08,9.33-12.23,8.71-8.44,16.1-19.51,22.85-6.48,3.96-10.06,2.81-14.19,7.85-.94,1.14-6.21,7.57-3.44,13.37,1.98,4.17,7.36,6.44,11.31,5.5,1.57-.37,2.01-1.04,3.77-2.14,7.76-4.85,13.28-.69,17.71-4.98,3.05-2.96,2.06-6.51,5.19-7.58,2.6-.88,5.27.89,6.3-.42.79-1-.58-2.3.07-3.43,1.33-2.29,7.98,1.27,11.66-1.81.7-.59.58-.81,2.24-4.23Z"/>
              </g>
              <path class="st4" d="M231.37,103.6c.76-.69,2.36-2.28,3.98-6.32,2.69-6.7.66-8.22,2.86-11.45,2.33-3.44,5.26-2.65,12.14-7,9.62-6.08,6.85-9.47,15.73-14.3,6.18-3.36,10.39-3.28,12.58-6.85,1.32-2.15.9-5,3.7-6.32.91-.42,1.38-.34,3.13-1.08.7-.3,2.87-1.21,4.12-2.38,2.41-2.26-.02-4.1,1.73-5.94,2.73-2.87,10.81-.61,13.48-3.67.95-1.09.1-1.59,1.44-3.21,1.84-2.23,4.95-3.12,5.57-3.29,1.87-.51,2.68-.29,4.25-.48,5.12-.64,5.73-4.14,9.93-5.32,5.68-1.6,8.38,3.84,16.87,2.76,3.53-.45,4.64-1.57,8.88-1.64,2.83-.04,6.73-.11,8.34,1.62,1.76,1.89-.39,4.67-1.01,11.92-.15,1.81.49,2.3.96,2.67,2.74,2.16,11.52.57,16.42-3.18,4.19-3.21,4.54-7.26,4.86-11.01.32-3.68,1.23-11.9-5.74-16.02-5.96-3.53-12.7-1.38-17.87-5.94-.92-.81-2.67-2.61-5.86-3.06-2.1-.29-3.32.21-5.25.45-7.6.95-10.8-4.12-16.97-3.07-2.57.44-1.94,1.31-6.11,3.12-9.02,3.92-14.76,1.06-21.21,5.06-1.82,1.13-1.65,1.53-4.42,3.27-3.12,1.95-4.73,2.32-7.93,4.45-2.59,1.72-1.81,1.67-3.59,2.7-5.73,3.33-8.09,1.98-14.46,5.95-1.74,1.09-6.93,3.87-10.85,7.69-6.19,6.04-4.09,9.31-8.71,11.19-4.05,1.65-6.3-.62-10.39,1.12-3.71,1.58-2.84,3.87-7.92,9.82-4.58,5.37-6.13,4.49-7.54,7.72-.96,2.18-1.57,5.1-4.62,7.79-.34.3-.72.58-1.17.86-3.16,1.96-5.26,1.34-7.28,3.32-2.8,2.74,0,5.15-2.67,8.05-2.38,2.58-5.29,1.41-8.03,3.83-4.32,3.82,0,9.36-4.12,11.71-1.89,1.08-3.29.33-4.84,1.44-2.13,1.53-.13,4.53.17,8.26.27,3.44-1.03,5.93-3.55,10.76-4.16,7.96-10.45,9.23-9.73,13.52.3,1.77,1.52,2.85,1.92,6.44.21,1.86.05,3.15-.01,4.11-.23,3.18-.76,10.53,4.12,15.54,2.18,2.25,2.83,1.33,6.57,4.51,5.41,4.59,3.75,6.25,7.11,8.11,5.65,3.12,11.74-.8,20.3,2.35,3.92,1.44,2.68,2.28,6.73,4.11,12.24,5.53,30.39,1,35.3-2.26.41-.27,1.08-.77,2.24-1.19,4.32-1.59,8.87.23,9.51-.6.39-.51-1.34-1.16-1.06-1.9.55-1.46,7.85-.53,14.35-2.3,10.29-2.8,14.84-11.38,15.22-12.12,1.04-2.04,4.77-9.38-.64-13.78-3.39-2.76-10.03-4.11-13.38-2.21-4.56,2.6-.24,9.71-4.77,11.93-2.39,1.17-4.46-.24-9.89-.49-8.09-.38-9.78,2.49-20.01,3.83-6.99.92-18.9,1.24-21.33-2.69-1.19-1.93-.03-4.76-1.51-5.05-.98-.19-1.76,1.01-3.81,1.28-1.48.2-2.32-.25-4.61-1.01-4.98-1.65-7.52-1.68-7.46-2.42.05-.6,1.68-.57,3.19-1.57,3.3-2.19,2.94-7.29,1.14-10.78-1.35-2.62-2.75-2.85-2.56-4.46.34-2.9,5-3.29,7.35-6.43,4.15-5.57-5.12-11.52-.82-16.08,1.9-2.02,4.19-1.35,7.52-4.37Z"/>
              <g>
                <path class="st3" d="M477.61,83.87c-1.58-.43,2.93-11.64-1.57-14.15-1.65-.92-3.67-.21-7.29-1.88-1.86-.86-2.94-1.79-3.44-2.17-6.3-4.76-26.76-2.09-36.52,3.09-.87.46-3.52,1.93-7.4,3.12-3.38,1.04-5.96,1.33-6.88,1.46-10.66,1.56-15.95,13.71-33.14,19.88-3.66,1.31-3.04.63-5.84,1.75-9.02,3.62-17.94,11.77-21.21,21.33-1.04,3.04-1.05,4.91-3.1,7.96-2.55,3.79-5,4.57-8.07,7.63-4.43,4.43-5.78,9.25-7.13,14.06-2.01,7.17-1.46,13.1-.96,16.19.81,5.02,2.59,16.06,10.46,18.59,3.62,1.16,4.93-.63,10.63-.24,8.51.58,10,4.88,17.55,7.33,9.76,3.17,24.33,1.51,33.08-5.03,4.05-3.02,6.26-6.64,12.52-8.48,4.74-1.39,6.31-.15,8.86-1.94,4.73-3.31,1.75-9.23,6.99-13.27,2.3-1.77,2.85-.62,6.68-2.8,5.86-3.33,5.7-6.66,10.2-8.55,3.79-1.59,4.63.46,9.7-.58,7.14-1.46,11.99-6.85,15.3-10.53,4.56-5.07,5.56-9.18,6.95-8.95,1.83.3-1.15,7.12,3.22,13.01,2.48,3.35,5.11,3.38,7.91,8.11,1.26,2.13,1.33,3.14,2.84,4.26,2.58,1.93,5.54,1.34,9.1,1.73,5.54.6,6.19,2.89,11.9,5,1.4.52,12.33,4.41,22.82.83,4.9-1.67,8.2-4.46,14.58-4.45,2.19,0,2.63.33,4.26.03,5.44-1.03,11.29-6.75,10.31-12.11-.41-2.25-2.09-4.79-4.99-6.06-6-2.61-9.89,3.45-20.83,3.17-7.47-.19-8.54-3.08-16.99-2.69-1.74.08-3.84.3-5.81-.8-2.42-1.36-2.62-3.6-4.37-7.15-2.33-4.69-3.5-3.82-5.1-7.32-3.01-6.58,1.32-9.23-1.69-16.48-1.14-2.76-2.91-5.11-1.77-6.27,1.01-1.03,3.07.14,4.73-.9,2.25-1.41.96-5.13,1.38-9.41.39-3.95,2.05-6.58,5.28-11.68,5.24-8.28,8.31-7.67,11.49-13.88,2.07-4.04,2.3-7.44,2.77-14.25.47-6.83.81-11.83-1.32-17.53-2.85-7.63-8.45-12.05-12.41-15.17-9.21-7.26-18.98-9.78-25.54-11.4-1.22-.3-8.78-1.14-23.9-2.82-7.12-.79-17.57-1.9-18.42.2-.33.82,1.02,1.52.63,2.31-.81,1.63-7.01-.48-13.67.42-6.21.84-12.91,4.32-16.6,9.77-1.03,1.52-4.15,6.12-2.77,11.2,1.9,6.99,11.17,10.67,18.43,10.47,4.51-.13,4.64-1.65,15.68-5.53,9.79-3.44,15.13-5.25,21.67-4.38,3.01.4,8.02,1.06,11.24,4.47,1.7,1.8,1.81,3.23,4.2,5.09,3.09,2.41,4.81,1.51,7.07,3.3,3.86,3.05,4,9.73,1.38,14.18-1.56,2.66-3.83,4.05-5.2,4.99-12.74,8.69-16.09,24.39-17.91,23.89Z"/>
                <path class="st3" d="M400.2,109.8c-2.76,3.43-3.41,3.78-6.5,7.37-4.48,5.2-3.71,5.15-6.68,8.4-5.13,5.62-6.65,4.93-8.92,8.49-3.14,4.92-3.65,11.58-.89,13.09,1.87,1.03,3.65-1.2,8.14-.72,4.24.45,4.89,2.68,7.81,2.49,3.48-.22,4.96-3.54,8.68-6.79,4.83-4.21,8.14-3.71,15.06-6.84,14.09-6.38,11.63-13.6,24.16-18.35,7.34-2.78,10.75-1.28,15.91-5.35,1.17-.92,7.74-6.11,6.04-11.75-1.22-4.06-6.26-6.81-10.45-6.46-1.67.14-2.24.69-4.24,1.47-8.81,3.44-13.63-1.06-18.94,2.28-3.66,2.31-3.33,5.68-6.71,6.25-2.8.47-5.18-1.48-6.48-.42-.99.81.16,2.17-.72,3.12-1.78,1.92-7.86-2.17-12.2.17-.82.44-.74.67-3.08,3.57Z"/>
              </g>
              <text class="st0" transform="translate(2.86 240.47)"><tspan x="0" y="0">emotion cell</tspan><tspan x="0" y="42.73">archive</tspan></text>
            </svg>
            <div id="terminal-output"></div>
            <div class="input-line">
                <label for="guest-id">ACCESS ID :</label>
                <input type="text" id="guest-id" autocomplete="off" maxlength="20">
            </div>
            <button id="access-button">[ 접속 (ENTER) ]</button>
        </div>
    </section>

    <div class="main-container">
        <div class="panel" id="panel-survey" data-target="content-survey">
            <div class="panel-content-wrapper"><div class="panel-archive-title font-thin"><span>EMOTION</span><span>CELL</span><span>ARCHIVE</span></div><h3 class="panel-number font-thick">#001</h3><h2 class="panel-main-title font-thick">MOTIF CELL CULTURING</h2></div>
        </div>
        <div class="panel" id="panel-sensitivity" data-target="content-sensitivity">
            <div class="panel-content-wrapper"><div class="panel-archive-title font-thin"><span>EMOTION</span><span>CELL</span><span>ARCHIVE</span></div><h3 class="panel-number font-thick">#002</h3><h2 class="panel-main-title font-thick">SENSITIVITY</h2></div>
        </div>
        <div class="panel" id="panel-result" data-target="content-result">
            <div class="panel-content-wrapper"><div class="panel-archive-title font-thin"><span>EMOTION</span><span>CELL</span><span>ARCHIVE</span></div><h3 class="panel-number font-thick">#003</h3><h2 class="panel-main-title font-thick">RESULT</h2></div>
        </div>
        
        <div class="content-area">
            <div class="content-block" id="content-survey"><section id="step2-protocol" class="fullscreen-container"></section></div>
            <div class="content-block" id="content-sensitivity"><section id="step3-culturing" class="fullscreen-container"></section></div>
            <div class="content-block" id="content-result"><section id="step4-result" class="fullscreen-container"></section></div>
        </div>
    </div>

<script>
// --- 전역 변수 ---
let userAnswers = {};
let resultChart = null;
let activeSketch = null;
let activePanelId = null;
let currentQuestion = 1;
let prevEmotionImage = null;

let totalQuestions = 6;
let visualizationState = 0;

let finalNucleusColor = [128, 128, 128];
let finalCellBodyColor = [30, 30, 30];
let finalInstability = 15;
let noiseOffset = 0;
let nucleusNoiseOffset = 500;
let userScores = {};
let culturedCell = null;
let currentEmotionImage = null; 
let logoImageDataURLCache = null;
let maxStepReached = 1; // [추가] 사용자가 도달한 최대 문항 번호 추적
let isSurveyLocked = false; // [추가] 결과 보기 후 수정 잠금 플래그
let transitionProgress = 0; // [추가] 0: 세포 100%, 1: 이미지 100%

// --- START: 수정된 전역 변수 ---
const CELL_DIAMETER = 160; // 세포 크기를 160으로 통일하여 키움
let lastCellPos = null;    // 패널 전환 시 위치/속도를 기억하는 변수
let lastCellVel = null;
// --- END: 수정된 전역 변수 ---

// --- DOM 요소 (기존과 동일) ---
const body = document.body;
const step1 = document.getElementById('step1-access');
const mainContainer = document.querySelector('.main-container');
const panels = document.querySelectorAll('.panel');
const contentBlocks = document.querySelectorAll('.content-block');
let accessButton, guestInput, terminalOutput;

const EMOTION_DATABASE = [
    { name: '기쁨', eng_name: 'Joy', vitality: 8, empathy: 7, self_assurance: 8, relationship_stability: 8, emotion_control: 7, life_meaning: 9,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%80%E1%85%B5%E1%84%88%E1%85%B3%E1%86%B7.png',
      commentary: "오늘 하루, 당신에게 기쁨 세포가 가득하길 바랍니다.",
      definition: "현재 상황에 대한 긍정적이고 만족스러운 반응입니다.",
      manifestation: "성공적인 경험이나 소중한 사람들과의 교류에서 주로 발현됩니다. 긍정적인 에너지가 느껴지며, 주변 사람들과 이 감정을 나누고 싶어집니다.",
      potential: "이 감정은 '감사'와 '희열'로 발전하여 삶의 긍정적인 면을 강화합니다. 과도한 기쁨은 때때로 비현실적인 기대로 이어질 수 있으니 균형이 중요합니다.",
      related_cells: ['희열', '만족', '애정'] },
    { name: '희열', eng_name: 'Ecstasy', vitality: 10, empathy: 8, self_assurance: 9, relationship_stability: 9, emotion_control: 8, life_meaning: 10,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%92%E1%85%B4%E1%84%8B%E1%85%A7%E1%86%AF.png',
      commentary: "가슴 벅찬 희열의 순간을 만끽하고, 다음 목표를 향한 에너지로 삼아보세요.",
      definition: "강렬한 기쁨과 성취감이 절정에 달한 상태입니다.",
      manifestation: "오랫동안 바라하던 목표를 달성했거나, 압도적인 경험을 할 때 나타납니다. 에너지가 폭발하며, 세상을 다 가진 듯한 느낌을 받습니다.",
      potential: "강력한 동기부여의 원천이 되지만, 이 감정에만 의존하면 일상적인 '기쁨'이나 '만족'을 무시하게 될 수 있습니다. 다음 목표를 향한 에너지로 전환하는 것이 좋습니다.",
      related_cells: ['기쁨', '들뜸', '자부심'] },
    { name: '만족', eng_name: 'Satisfaction', vitality: 6, empathy: 7, self_assurance: 8, relationship_stability: 7, emotion_control: 8, life_meaning: 8,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%86%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A9%E1%86%A8.png',
      commentary: "지금의 만족감을 기반으로 새로운 기대를 설정해 보는 건 어떨까요?",
      definition: "자신의 상태나 결과에 대해 부족함 없이 흡족한 상태입니다.",
      manifestation: "기대했던 바가 충족되었을 때 나타납니다. '희열'처럼 뜨겁진 않지만, '안도'보다 더 깊은 긍정 상태이며, 내면이 꽉 찬 느낌을 줍니다.",
      potential: "현재 상태에 안주하여 '무기력'이나 '지루함'으로 변질될 수 있습니다. 이 만족감을 기반으로 새로운 '기대'를 설정하는 것이 좋습니다.",
      related_cells: ['안도', '흐뭇함', '기쁨'] },
    { name: '자부심', eng_name: 'Pride', vitality: 7, empathy: 6, self_assurance: 10, relationship_stability: 7, emotion_control: 8, life_meaning: 9,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/985946f8241ef09cf3e5c090a52f4d7c2dccc8f5/%E1%84%8C%E1%85%B5-%E1%84%8C%E1%85%A1%E1%84%87%E1%85%AE%E1%84%89%E1%85%B5%E1%86%B7.png',
      commentary: "스스로에 대한 긍지는 당신을 더 단단하게 만들어 줄 겁니다.",
      definition: "스스로의 성취, 능력, 또는 가치에 대해 긍정적으로 평가하는 감정입니다.",
      manifestation: "자신의 선택과 행동에 대한 강한 확신으로 나타납니다. 타인의 평가에 쉽게 흔들리지 않는 내면의 단단함을 느낍니다.",
      potential: "'자신감'과 '활기'의 원천이 됩니다. 다만, 과도할 경우 '오만'이 되어 타인에 대한 '공감' 능력을 저하시킬 수 있습니다.",
      related_cells: ['만족', '희열', '냉소'] },
    { name: '안도', eng_name: 'Relief', vitality: 5, empathy: 7, self_assurance: 7, relationship_stability: 8, emotion_control: 9, life_meaning: 7,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%83%E1%85%A9.png',
      commentary: "마음의 짐을 내려놓은 당신, 잠시 평온을 즐겨도 괜찮습니다.",
      definition: "걱정이나 긴장 상태가 해소되면서 마음이 놓이는 상태입니다.",
      manifestation: "불확실한 결과가 긍정적으로 끝났거나, 위험이 사라졌을 때 나타납니다. '기쁨'보다는 '평온'에 가까운 낮은 에너지를 동반합니다.",
      potential: "스트레스를 해소하고 '감정 통제' 상태를 회복시킵니다. 이 상태가 지속되면 '만족'이나 '평온'으로 이어집니다.",
      related_cells: ['만족', '흐뭇함', '긴장'] },
    { name: '기대', eng_name: 'Anticipation', vitality: 7, empathy: 6, self_assurance: 7, relationship_stability: 6, emotion_control: 6, life_meaning: 8,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%80%E1%85%B5%E1%84%83%E1%85%A2.png',
      commentary: "설레는 기다림의 시간이 당신의 오늘을 더욱 활기차게 만들고 있네요.",
      definition: "미래의 긍정적인 결과를 바라며 기다리는 감정입니다.",
      manifestation: "설렘과 약간의 '긴장'을 동반합니다. 미래에 대한 긍정적인 상상을 하며, 현재의 '활력'이 되기도 합니다.",
      potential: "목표 지향적인 행동을 촉진합니다. 기대가 충족되면 '기쁨'이나 '희열'로, 좌절되면 '실망'이나 '서운'함으로 발전할 수 있습니다.",
      related_cells: ['들뜸', '조급', '희열'] },
    { name: '흐뭇함', eng_name: 'Contentment', vitality: 6, empathy: 8, self_assurance: 7, relationship_stability: 9, emotion_control: 8, life_meaning: 8,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/985946f8241ef09cf3e5c090a52f4d7c2dccc8f5/%E1%84%8C%E1%85%B5-%E1%84%92%E1%85%B3%E1%84%86%E1%85%AE%E1%86%BA.png',
      commentary: "타인을 보며 느끼는 따뜻한 흐뭇함은 당신의 마음이 건강하다는 증거입니다.",
      definition: "마음에 흡족하여 기분이 좋은 상태로, 주로 타인이나 관계 속에서 느껴집니다.",
      manifestation: "타인의 긍정적인 모습을 보거나, '애정'을 느낄 때 잔잔한 미소와 함께 나타납니다. '자부심'보다 부드럽고 '공감'과 맞닿아 있습니다.",
      potential: "'애정'이나 '공감'의 감정을 더욱 깊게 만듭니다. 타인에 대한 긍정적인 피드백을 통해 관계를 강화시킬 수 있습니다.",
      related_cells: ['애정', '만족', '공감'] },
    { name: '애정', eng_name: 'Affection', vitality: 7, empathy: 9, self_assurance: 7, relationship_stability: 10, emotion_control: 8, life_meaning: 8,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%A2%E1%84%8C%E1%85%A5%E1%86%BC.png',
      commentary: "누군가를 아끼는 마음은 당신의 삶을 더욱 풍요롭게 합니다.",
      definition: "대상을 몹시 아끼고 귀중하게 여기는 마음입니다.",
      manifestation: "타인과의 '관계 안정'에서 오는 깊은 유대감으로 나타납니다. 상대를 보호하고 싶은 마음과 강한 '공감'을 동반합니다.",
      potential: "'흐뭇함'과 '기쁨'의 원천이 됩니다. 이 감정은 삶의 의미를 부여하지만, 때로 '질투'나 '배신'감의 원인이 되기도 합니다.",
      related_cells: ['흐뭇함', '공감', '질투'] },
    { name: '공감', eng_name: 'Empathy', vitality: 6, empathy: 10, self_assurance: 6, relationship_stability: 8, emotion_control: 7, life_meaning: 7,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A1%E1%86%B7.png',
      commentary: "깊은 공감 능력은 때로 지치게 하지만, 당신을 더 나은 사람으로 만듭니다.",
      definition: "타인의 감정이나 경험을 자신도 동일하게 느끼는 능력입니다.",
      manifestation: "타인의 기쁨이나 슬픔에 깊이 이입하며, '관계 안정'의 기반이 됩니다. 높은 '공감'은 때로 감정적 소모를 유발할 수 있습니다.",
      potential: "'애정'이나 '서운함' 등 관계 중심적 감정으로 발전합니다. 타인과의 경계를 설정하여 스스로를 보호하는 '감정 통제'가 필요할 수 있습니다.",
      related_cells: ['애정', '슬픔', '서운'] },
    { name: '활기', eng_name: 'Vigor', vitality: 9, empathy: 6, self_assurance: 7, relationship_stability: 6, emotion_control: 7, life_meaning: 7,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%92%E1%85%AA%E1%86%AF%E1%84%80%E1%85%B5.png',
      commentary: "넘치는 활기를 좋은 곳에 사용한다면, 분명 멋진 결과가 있을 거예요.",
      definition: "신체적, 정신적으로 생동감이 넘치는 상태입니다.",
      manifestation: "높은 '활력' 점수에서 나타나며, 새로운 일을 '시작할 힘'이 넘칩니다. 긍정적인 태도와 높은 집중력을 보입니다.",
      potential: "'들뜸'이나 '기쁨'으로 이어지기 좋은 상태입니다. 이 에너지를 구체적인 '기대'나 목표에 사용하면 '성취감'을 얻을 수 있습니다.",
      related_cells: ['들뜸', '기대', '기쁨'] },
    { name: '들뜸', eng_name: 'Excitement', vitality: 10, empathy: 6, self_assurance: 6, relationship_stability: 7, emotion_control: 5, life_meaning: 7,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%83%E1%85%B3%E1%86%AF%E1%84%84%E1%85%B3%E1%86%B7.png',
      commentary: "두근거리는 마음을 진정시키고, 이 에너지를 어디에 쓸지 집중해 보세요.",
      definition: "기대나 흥분으로 마음이 가라앉지 않고 부풀어 오른 상태입니다.",
      manifestation: "매우 높은 '활력'과 다소 낮은 '감정 통제' 상태에서 나타납니다. 안절부절못하거나, 집중력이 분산되는 경향이 있습니다.",
      potential: "긍정적인 이벤트가 발생하면 '희열'로 이어질 수 있으나, 쉽게 '조급'함으로 변질되거나 에너지가 방전되어 '허무'를 느낄 수 있습니다.",
      related_cells: ['희열', '기대', '조급'] },
    { name: '슬픔', eng_name: 'Sorrow', vitality: 3, empathy: 7, self_assurance: 4, relationship_stability: 5, emotion_control: 3, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/main/%E1%84%89%E1%85%B3%E1%86%AF%E1%84%91%E1%85%B3%E1%86%B7.png',
      commentary: "슬픔을 충분히 느끼는 것은, 마음이 회복되고 있다는 신호입니다.",
      definition: "상실, 좌절, 또는 불행으로 인해 마음이 아프고 무거운 상태입니다.",
      manifestation: "낮은 '활력'과 낮은 '삶의 의미감'으로 나타납니다. 눈물이 나거나, 혼자 있고 싶어하며, 타인의 '공감'을 필요로 하기도 합니다.",
      potential: "감정을 충분히 느끼고 해소하는 과정이 필요합니다. 억압되면 '무기력'이나 '공허'로 발전할 수 있습니다. '공감'을 통해 타인과 유대감을 형성할 수도 있습니다.",
      related_cells: ['외로움', '자책', '공감'] },
    { name: '허무', eng_name: 'Nihility', vitality: 2, empathy: 4, self_assurance: 3, relationship_stability: 3, emotion_control: 2, life_meaning: 1,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/985946f8241ef09cf3e5c090a52f4d7c2dccc8f5/%E1%84%8C%E1%85%B5-%E1%84%92%E1%85%A5%E1%84%86%E1%85%AE.png',
      commentary: "모든 것이 무의미하게 느껴질 땐, 아주 작은 의미부터 다시 찾아보는 노력이 필요합니다.",
      definition: "모든 것이 무의미하고 헛되게 느껴지는 감정입니다.",
      manifestation: "극도로 낮은 '삶의 의미감'과 '활력'이 특징입니다. 어떤 일에도 동기를 느끼지 못하며, '냉소'적인 태도를 보일 수 있습니다.",
      potential: "'공허'와 '무기력'의 가장 깊은 형태입니다. 스스로의 가치를 재발견하거나, 새로운 '삶의 의미'를 찾는 노력이 필요합니다.",
      related_cells: ['공허', '무기력', '냉소'] },
    { name: '서운', eng_name: 'Disappointment', vitality: 4, empathy: 6, self_assurance: 4, relationship_stability: 3, emotion_control: 4, life_meaning: 4,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%89%E1%85%A5%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%B7.png',
      commentary: "서운함은 관계에 대한 기대가 있었다는 증거입니다. 솔직한 대화가 필요할지도 모릅니다.",
      definition: "기대에 못 미치는 대우를 받아 마음이 섭섭하고 아쉬운 감정입니다.",
      manifestation: "주로 '관계 안정'이 흔들렸을 때 나타납니다. 타인에게 섭섭함을 표현하거나, 혼자 '위축'될 수 있습니다.",
      potential: "관계에 대한 '기대'가 있었음을 의미합니다. 방치되면 '불신'이나 '외로움'으로, 해소되면 '관계 안정'을 회복할 수 있습니다.",
      related_cells: ['억울', '외로움', '불신'] },
    { name: '자책', eng_name: 'Self-blame', vitality: 3, empathy: 5, self_assurance: 1, relationship_stability: 4, emotion_control: 4, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%8C%E1%85%A1%E1%84%8E%E1%85%A2%E1%86%A8.png',
      commentary: "과거의 실수는 오늘의 당신을 위한 교훈일 뿐, 짐이 되어서는 안 됩니다.",
      definition: "자신의 잘못이나 부족함을 스스로 탓하며 괴로워하는 감정입니다.",
      manifestation: "극도로 낮은 '자기 확신' 점수에서 나타납니다. 과거의 행동을 반복적으로 후회하며, '죄책감'과 '위축'을 동반합니다.",
      potential: "낮은 '자기 확신'을 더욱 악화시킵니다. 스스로를 용서하고, 실패를 배움의 과정으로 받아들이는 태도 전환이 필요합니다.",
      related_cells: ['죄책감', '위축', '슬픔'] },
    { name: '외로움', eng_name: 'Loneliness', vitality: 3, empathy: 5, self_assurance: 4, relationship_stability: 2, emotion_control: 3, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%AC%E1%84%85%E1%85%A9%E1%84%8B%E1%85%AE%E1%86%B7.png',
      commentary: "외로움은 혼자라는 느낌이 아니라, 연결되고 싶은 마음의 다른 표현입니다.",
      definition: "타인과 의미 있는 관계를 맺지 못하고 홀로 격리되었다고 느끼는 감정입니다.",
      manifestation: "낮은 '관계 안정' 점수와 '활력' 저하로 나타납니다. 타인과 연결되고 싶은 욕구와 동시에 '위축'되는 모습을 보입니다.",
      potential: "'공감' 능력을 바탕으로 새로운 관계를 맺거나, 기존 관계를 개선하려는 노력이 필요합니다. 방치되면 '공허'나 '무기력'으로 이어질 수 있습니다.",
      related_cells: ['슬픔', '공허', '위축'] },
    { name: '억울', eng_name: 'Unfairness', vitality: 5, empathy: 4, self_assurance: 3, relationship_stability: 2, emotion_control: 2, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/0064a5c0335ac7ead04ec8429d13c61d47ead0aa/%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AE%E1%86%AF1.png',
      commentary: "억울한 마음을 너무 오래 담아두지 마세요. 당신의 에너지는 더 좋은 곳에 쓰여야 합니다.",
      definition: "부당한 대우를 받거나 오해를 받아 마음이 답답하고 분한 감정입니다.",
      manifestation: "낮은 '자기 확신'과 '관계 안정' 속에서 '분개' 직전의 에너지를 가집니다. 자신의 무고함을 증명하고 싶어 합니다.",
      potential: "적극적으로 해명하거나 상황을 바로잡으려 노력하면 '자부심'을 회복할 수 있습니다. 억압되면 '분개'나 '무기력'으로 변질될 수 있습니다.",
      related_cells: ['분개', '답답', '서운'] },
    { name: '분개', eng_name: 'Indignation', vitality: 8, empathy: 2, self_assurance: 4, relationship_stability: 1, emotion_control: 1, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%87%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A2%20(1).png',
      commentary: "뜨거운 분노의 에너지를 파괴가 아닌, 문제 해결을 위한 동력으로 바꿔보세요.",
      definition: "매우 부당한 일을 겪어 격렬하게 화가 나는 감정입니다.",
      manifestation: "매우 높은 '활력', 낮은 '공감' 및 '감정 통제', 극도로 낮은 '관계 안정'이 특징입니다. 공격적인 태도나 강한 비난으로 표출될 수 있습니다.",
      potential: "파괴적인 행동으로 이어질 수 있어 즉각적인 '감정 통제' 노력이 필요합니다. 이 에너지를 문제 해결을 위한 '활력'으로 전환할 수 있습니다.",
      related_cells: ['억울', '배신', '질투'] },
    { name: '질투', eng_name: 'Jealousy', vitality: 6, empathy: 3, self_assurance: 2, relationship_stability: 1, emotion_control: 2, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%90%E1%85%AE.png',
      commentary: "질투는 당신이 무엇을 원하는지 알려주는 나침반이 될 수 있습니다.",
      definition: "타인이 가진 것을 부러워하거나, 자신이 소중히 여기는 관계를 잃을까 두려워하는 감정입니다.",
      manifestation: "낮은 '자기 확신'과 '관계 안정'이 핵심입니다. 타인과 자신을 비교하며, '불신'이나 '냉소'적인 태도를 보일 수 있습니다.",
      potential: "자신이 무엇을 원하는지(낮은 '자기 확신'의 원인) 파악하는 계기가 될 수 있습니다. '자부심'을 키우는 활동이 필요합니다.",
      related_cells: ['배신', '불신', '자책'] },
    { name: '무시', eng_name: 'Ignored', vitality: 4, empathy: 1, self_assurance: 3, relationship_stability: 1, emotion_control: 3, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%86%E1%85%AE%E1%84%89%E1%85%B5.png',
      commentary: "타인의 인정이 아닌, 스스로의 가치를 믿는 것에서부터 변화는 시작됩니다.",
      definition: "타인에게 가치 없거나 하찮게 여겨진다고 느끼는 감정입니다.",
      manifestation: "극도로 낮은 '공감'(타인이 나에게 공감하지 않음)과 '관계 안정'이 특징입니다. '위축'되거나 반대로 '분개'할 수 있습니다.",
      potential: "'자부심'을 훼손하며, '냉소'나 '외로움'을 유발합니다. 자신의 가치를 스스로 인정하는 '자기 확신' 회복이 중요합니다.",
      related_cells: ['위축', '냉소', '분개'] },
    { name: '답답', eng_name: 'Frustration', vitality: 4, empathy: 5, self_assurance: 4, relationship_stability: 4, emotion_control: 3, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/985946f8241ef09cf3e5c090a52f4d7c2dccc8f5/%E1%84%8C%E1%85%B5-%E1%84%83%E1%85%A1%E1%86%B8%E1%84%83%E1%85%A1%E1%86%B82.png',
      commentary: "답답한 마음이 들 땐, 잠시 멈춰서 엉킨 실타래를 하나씩 풀어보는 시간이 필요합니다.",
      definition: "일이 뜻대로 되지 않거나, 마음이 풀리지 않아 갑갑한 상태입니다.",
      manifestation: "중간 정도의 부정적 감정들이 복합적으로 작용합니다. '조급'함과 '긴장'의 전조 증상일 수 있습니다.",
      potential: "문제의 원인을 명확히 파악하려는 노력이 '조급'함이나 '긴장'을 예방할 수 있습니다. 방치되면 '무기력'으로 이어질 수 있습니다.",
      related_cells: ['조급', '긴장', '억울'] },
    { name: '조급', eng_name: 'Impatience', vitality: 7, empathy: 4, self_assurance: 5, relationship_stability: 5, emotion_control: 1, life_meaning: 4,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8C%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%86%B7.png',
      commentary: "빠른 것만이 정답은 아닙니다. 잠시 숨을 고르고 자신의 속도를 찾아보세요.",
      definition: "마음이 급하여 안절부절못하는 상태입니다.",
      manifestation: "극도로 낮은 '감정 통제'와 높은 '활력'이 특징입니다. 침착하지 못하고, 실수나 성급한 결정을 내리기 쉽습니다.",
      potential: "상황을 통제하려는 욕구에서 비롯됩니다. '안도' 상태를 목표로, 호흡을 가다듬고 우선순위를 정하는 것이 도움이 됩니다.",
      related_cells: ['긴장', '들뜸', '불신'] },
    { name: '불신', eng_name: 'Distrust', vitality: 5, empathy: 3, self_assurance: 4, relationship_stability: 1, emotion_control: 4, life_meaning: 3,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%87%E1%85%AE%E1%86%AF%E1%84%89%E1%85%B5%E1%86%AB.png',
      commentary: "한 번 깨진 믿음을 회복하기는 어렵지만, 모든 관계가 그렇지는 않을 겁니다.",
      definition: "타인이나 상황을 믿지 못하고 의심하는 감정입니다.",
      manifestation: "극도로 낮은 '관계 안정'이 특징입니다. 타인의 의도를 의심하거나, 방어적인 태도를 취하며 '긴장' 상태를 유지합니다.",
      potential: "'배신'의 경험에서 비롯될 수 있으며, '냉소'나 '외로움'을 강화합니다. 관계에서 '안도'감을 회복하는 것이 중요합니다.",
      related_cells: ['배신', '긴장', '냉소'] },
    { name: '위축', eng_name: 'Intimidation', vitality: 2, empathy: 5, self_assurance: 2, relationship_stability: 3, emotion_control: 2, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B1%E1%84%8E%E1%85%AE%E1%86%A8.png',
      commentary: "괜찮아요. 지금은 잠시 움츠러들어도, 다시 기지개를 켤 힘은 당신 안에 있습니다.",
      definition: "자신감이 없어 기를 펴지 못하고 움츠러드는 상태입니다.",
      manifestation: "낮은 '활력'과 '자기 확신'이 특징입니다. 타인의 시선을 의식하고, 자신의 의견을 표현하기 어려워하며 '외로움'을 느낍니다.",
      potential: "'자책'과 '무시'당한 경험이 원인일 수 있습니다. 작은 성공(높은 '자기 확신')을 통해 '자부심'을 회복하는 것이 필요합니다.",
      related_cells: ['자책', '외로움', '무시'] },
    { name: '죄책감', eng_name: 'Guilt', vitality: 3, empathy: 6, self_assurance: 1, relationship_stability: 4, emotion_control: 4, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8C%E1%85%AC%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%80%E1%85%A1%E1%86%B7.png',
      commentary: "죄책감은 당신이 좋은 사람이기 때문에 느끼는 감정입니다. 스스로를 용서할 기회를 주세요.",
      definition: "스스로의 행동이 도덕적, 윤리적 기준에 어긋났다고 느껴 괴로워하는 감정입니다.",
      manifestation: "극도로 낮은 '자기 확신'과 높은 '공감'(피해자에 대한) 능력에서 비롯됩니다. '자책'과 유사하나 타인에 대한 미안함이 더 큽니다.",
      potential: "사과나 보상 행동을 통해 '관계 안정'을 회복하려는 시도로 이어질 수 있습니다. 용서를 통해 '안도'감으로 나아갈 수 있습니다.",
      related_cells: ['자책', '서운', '공감'] },
    { name: '배신', eng_name: 'Betrayal', vitality: 6, empathy: 2, self_assurance: 3, relationship_stability: 1, emotion_control: 2, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%89%E1%85%A5_%E1%84%87%E1%85%A2%E1%84%89%E1%85%B5%E1%86%AB.png',
      commentary: "깊은 상처는 당신의 잘못이 아닙니다. 이 경험이 당신을 무너뜨리지 않도록 스스로를 지켜주세요.",
      definition: "믿었던 사람이나 관계로부터 신뢰가 깨졌을 때 느끼는 강한 부정적 감정입니다.",
      manifestation: "극도로 낮은 '관계 안정'과 높은 '활력'(분노 에너지)이 특징입니다. '분개'나 '억울'함을 동반합니다.",
      potential: "강한 '불신'과 '냉소'를 유발합니다. 이 경험을 통해 관계의 의미를 재정립하고, '자기 확신'을 회복하는 과정이 필요합니다.",
      related_cells: ['분개', '불신', '억울'] },
    { name: '무기력', eng_name: 'Lethargy', vitality: 1, empathy: 3, self_assurance: 2, relationship_stability: 3, emotion_control: 2, life_meaning: 1,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%86%E1%85%AE%E1%84%80%E1%85%B5%E1%84%85%E1%85%A7%E1%86%A8.png',
      commentary: "오늘 하루는 무기력 세포를 떨쳐내고 활기차게 보내봅시다!",
      definition: "에너지와 동기를 완전히 상실하여 아무것도 하고 싶지 않은 상태입니다.",
      manifestation: "모든 6개 축의 점수가 전반적으로 매우 낮습니다. 어떤 것에도 의미를 찾지 못하고, 신체적, 정신적 침체를 겪습니다.",
      potential: "'허무'나 '공허'의 구체적인 발현입니다. 외부의 개입이나 환경의 변화, 혹은 아주 작은 '활력'을 찾는 것이 시급합니다.",
      related_cells: ['허무', '공허', '자책'] },
    { name: '공허', eng_name: 'Emptiness', vitality: 2, empathy: 3, self_assurance: 3, relationship_stability: 2, emotion_control: 2, life_meaning: 1,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A5%E1%84%92%E1%85%A1%E1%86%B7.png',
      commentary: "텅 빈 마음을 억지로 채우려 하지 마세요. 때로는 비어있는 시간도 필요합니다.",
      definition: "마음 속이 텅 비어 아무것도 없는 듯한 느낌입니다.",
      manifestation: "극도로 낮은 '삶의 의미감'과 '외로움'(낮은 관계 안정)에서 비롯됩니다. '허무'와 유사하나, 관계에 대한 결핍감이 더 큽니다.",
      potential: "'무기력' 상태를 유발합니다. 새로운 '삶의 의미'를 찾거나, 타인과 '공감'대를 형성하는 것이 회복에 도움이 될 수 있습니다.",
      related_cells: ['허무', '무기력', '외로움'] },
    { name: '냉소', eng_name: 'Cynicism', vitality: 5, empathy: 2, self_assurance: 5, relationship_stability: 3, emotion_control: 6, life_meaning: 2,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/9d6ee4d02c6eedfeffbf863904397a6bf429317b/%E1%84%82%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A9.png',
      commentary: "냉소는 때로 상처로부터 자신을 지키는 갑옷이 되기도 합니다.",
      definition: "타인이나 세상을 불신하고 경멸하며 비웃는 태도입니다.",
      manifestation: "낮은 '공감' 능력과 낮은 '삶의 의미감'이 특징입니다. '자기 확신'은 어느 정도 있으나, '관계 안정'은 낮습니다.",
      potential: "'배신'이나 '무시'당한 경험이 누적되어 방어기제로 작용할 수 있습니다. '공감' 능력을 회복하고 '삶의 의미'를 재설정할 필요가 있습니다.",
      related_cells: ['불신', '무시', '허무'] },
    { name: '긴장', eng_name: 'Tension', vitality: 7, empathy: 5, self_assurance: 5, relationship_stability: 4, emotion_control: 3, life_meaning: 4,
      image_url: 'https://raw.githubusercontent.com/youngwookim11/eca-image-storage/985946f8241ef09cf3e5c090a52f4d7c2dccc8f5/%E1%84%8C%E1%85%B5-%E1%84%80%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC.png',
      commentary: "적당한 긴장은 더 좋은 결과를 위한 준비운동과 같습니다.",
      definition: "중요한 일이나 불확실한 상황을 앞두고 마음을 놓지 못하는 상태입니다.",
      manifestation: "높은 '활력'(각성)과 낮은 '감정 통제'가 특징입니다. '조급'함과 유사하나, '삶의 의미감'(중요도)이 더 높게 작용합니다.",
      potential: "문제를 해결하기 위한 에너지원이 될 수 있습니다. 성공적으로 해결되면 '안도'나 '희열'로, 실패하면 '좌절'이나 '자책'으로 이어집니다.",
      related_cells: ['조급', '기대', '안도'] },
];
// --- END: 모든 이미지 링크가 적용된 데이터베이스 ---

// --- HTML 템플릿 (기존과 동일) ---
const surveyHTML = `
    <div class="protocol-page" id="survey-page-container">
        <div class="content-wrapper">
            <div class="container-header">
                <span>[ FILE: GUEST_ANALYSIS.LOG ]</span>
                <span id="progress-text"></span> 
            </div>
            <div id="progress-bar-container"><div id="progress-indicator"></div></div>
            <div class="navigation-buttons">
                <button type="button" id="prev-question" class="nav-button">&lt;</button>
                <button type="button" id="next-question" class="nav-button">&gt;</button>
            </div>
            <form id="protocol-form">
                <div class="question-step" id="q1"> <h2 class="main-question">"요즘 나는 무언가를 시작할 힘이 난다."</h2> <p class="sub-text">* 현재 '활기'의 정도를 측정합니다. (무기력 ↔ 활기)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q1_vitality" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q1_vitality" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q1_vitality" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q1_vitality" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q1_vitality" data-value="5">매우 그렇다</button> </div> </div> <div class="question-step" id="q2"> <h2 class="main-question">"타인의 감정이나 생각에 쉽게 공감한다."</h2> <p class="sub-text">* 현재 '공감'의 정도를 측정합니다. (무시 ↔ 공감)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q2_empathy" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q2_empathy" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q2_empathy" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q2_empathy" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q2_empathy" data-value="5">매우 그렇다</button> </div> </div> <div class="question-step" id="q3"> <h2 class="main-question">"나는 내 선택과 행동에 만족한다."</h2> <p class="sub-text">* 현재 '자기 확신'의 정도를 측정합니다. (자책 ↔ 자부심)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q3_self_assurance" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q3_self_assurance" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q3_self_assurance" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q3_self_assurance" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q3_self_assurance" data-value="5">매우 그렇다</button> </div> </div> <div class="question-step" id="q4"> <h2 class="main-question">"사람들과의 관계가 나를 편안하게 만든다."</h2> <p class="sub-text">* 현재 '관계 안정'의 정도를 측정합니다. (배신/불신 ↔ 애정/안도)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q4_relationship_stability" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q4_relationship_stability" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q4_relationship_stability" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q4_relationship_stability" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q4_relationship_stability" data-value="5">매우 그렇다</button> </div> </div> <div class="question-step" id="q5"> <h2 class="main-question">"감정이 쉽게 요동치지 않고, 스스로 조절할 수 있다."</h2> <p class="sub-text">* 현재 '감정 통제'의 정도를 측정합니다. (조급/긴장 ↔ 안도)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q5_emotion_control" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q5_emotion_control" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q5_emotion_control" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q5_emotion_control" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q5_emotion_control" data-value="5">매우 그렇다</button> </div> </div> <div class="question-step" id="q6"> <h2 class="main-question">"요즘 내 삶이 의미 있고 가치 있다고 느낀다."</h2> <p class="sub-text">* 현재 '삶의 의미감'의 정도를 측정합니다. (허무/공허/냉소 ↔ 희열/기대)</p> <div class="choices button-choices-scale"> <button type="button" class="choice-button" data-question="q6_life_meaning" data-value="1">매우 아니다</button> <button type="button" class="choice-button" data-question="q6_life_meaning" data-value="2">아니다</button> <button type="button" class="choice-button" data-question="q6_life_meaning" data-value="3">보통</button> <button type="button" class="choice-button" data-question="q6_life_meaning" data-value="4">그렇다</button> <button type="button" class="choice-button" data-question="q6_life_meaning" data-value="5">매우 그렇다</button> </div> </div>
            </form>
        </div>
    </div>
`;
const sensitivityHTML = `
    <div class="culturing-page" id="sensitivity-page-container">
        <div class="content-wrapper">
            <div class="container-header"><span>[ FILE: CELL_SENSITIVITY.LOG ]</span></div>
            <h2 id="step3-title">[ 민감도 설정 ]</h2>
            <p class="sub-text" style="text-align: center;">* 세포의 최종 반응성을 조절합니다. 외부 자극에 대한 불안정성을 결정합니다.</p>
            <div class="slider-wrapper">
                <span class="slider-label">둔감</span>
                <input type="range" id="sensitivity-slider" min="0" max="100" value="50">
                <span class="slider-label">민감</span>
            </div>
            <button id="inject-button">
                <div id="inject-progress-fill"></div>
                <span id="inject-text">[ 주입 ]</span>
            </button>
        </div>
    </div>
`;
const resultHTML = `
    <div class="page-container result-page" id="result-page-container"> 
        <div class="container-header"><span>[ FILE: ECA_CELL_CULTURE.LOG ]</span><span id="result-id-display"></span></div>
        <h2 class="result-title">배양된 감정세포:</h2>
        <h1 id="result-cell-name-display"></h1>
        <div class="result-content">
            <div class="chart-container"><canvas id="result-chart"></canvas></div>
            <div id="result-analysis-data"></div>
            <div id="result-cell-info"></div>
        </div>
        <p class="final-message">* 이 감정세포는 당신의 현재 심리 상태를 반영합니다.</p>
        <div class="result-buttons"><button id="restart-button">[ 다시 측정하기 ]</button><button id="print-button">[ 영수증 출력하기 ]</button></div>
    </div>
`;

// --- 초기화 및 DOM 바인딩 (기존과 동일) ---
function initContent() {
    document.getElementById('step2-protocol').innerHTML = surveyHTML;
    document.getElementById('step3-culturing').innerHTML = sensitivityHTML;
    document.getElementById('step4-result').innerHTML = resultHTML;
}
initContent();

let progressBar, choiceButtons, progressText, sensitivitySlider, injectButton, injectProgressFill, injectText, resultIdDisplay, resultCellInfo, chartCanvas, resultCellNameDisplay, resultAnalysisData;

function rebindDOM() {
    progressBar = document.getElementById('progress-indicator');
    choiceButtons = document.querySelectorAll('.choice-button');
    progressText = document.getElementById('progress-text');
    sensitivitySlider = document.getElementById('sensitivity-slider');
    injectButton = document.getElementById('inject-button');
    injectProgressFill = document.getElementById('inject-progress-fill');
    injectText = document.getElementById('inject-text');
    resultIdDisplay = document.getElementById('result-id-display');
    resultCellInfo = document.getElementById('result-cell-info');
    chartCanvas = document.getElementById('result-chart');
    resultCellNameDisplay = document.getElementById('result-cell-name-display');
    resultAnalysisData = document.getElementById('result-analysis-data');

    if (choiceButtons) {
        choiceButtons.forEach(button => {
            button.addEventListener('click', (e) => nextStep(e.currentTarget.dataset.question, e.currentTarget.dataset.value));
        });
    }
    if (injectButton) injectButton.addEventListener('click', handleInjection);
    const restartButton = document.getElementById('restart-button');
    if (restartButton) restartButton.addEventListener('click', () => location.reload());
    const printButton = document.getElementById('print-button');
    if (printButton) printButton.addEventListener('click', handlePrint);
    const prevBtn = document.getElementById('prev-question');
    const nextBtn = document.getElementById('next-question');
    if (prevBtn) prevBtn.addEventListener('click', goToPrevQuestion);
    if (nextBtn) nextBtn.addEventListener('click', goToNextQuestion);
}

// --- 핵심 로직 (기존과 동일) ---
function typeEffect(element, text, delay, callback) {
    let i = 0;
    element.innerHTML = "";
    function typing() {
        if (i < text.length) {
            element.innerHTML += text.charAt(i);
            i++;
            setTimeout(typing, delay);
        } else if (callback) {
            callback();
        }
    }
    typing();
}

function handleAccess() {
    const guestID = guestInput.value;
    
    // [수정됨] 정규표현식을 /^[a-zA-Z0-9]+$/ 로 변경하여 영문과 숫자를 모두 허용
    if (guestID && /^[a-zA-Z0-9]+$/.test(guestID)) {
        userAnswers['accessID'] = guestID.toUpperCase();
        accessButton.disabled = true;
        typeEffect(terminalOutput, "ACCESSING E.C.A. ARCHIVE...", 50, () => {
            setTimeout(() => {
                typeEffect(terminalOutput, `ACCESSING E.C.A. ARCHIVE...\nIDENTITY VERIFIED: ${userAnswers['accessID']}\n\n[ 감정세포 배양 프로토콜을 시작합니다. ]`, 50, () => {
                    setTimeout(() => {
                        step1.style.display = 'none';
                        mainContainer.style.display = 'flex';
                        body.classList.add('main-active');
                        activatePanel(document.getElementById('panel-survey'));
                    }, 1000);
                });
            }, 800);
        });
    } else {
        // [수정됨] 에러 메시지도 조건에 맞게 변경
        typeEffect(terminalOutput, "ERROR: ACCESS ID는 영문과 숫자만 입력 가능합니다.", 50, null);
    }
}

function showQuestion(qNum) {
    document.querySelectorAll('.question-step').forEach(q => q.style.display = 'none');
    const qEl = document.getElementById('q' + qNum);
    if (qEl) qEl.style.display = 'block';
    const answeredCount = Object.keys(userAnswers).filter(k => k.startsWith('q')).length;
    if (progressBar) progressBar.style.width = (answeredCount / totalQuestions) * 100 + '%';
    if (progressText) progressText.textContent = `[ ${qNum} / ${totalQuestions} ]`;
    const prevBtn = document.getElementById('prev-question');
    const nextBtn = document.getElementById('next-question');
    if (prevBtn) prevBtn.disabled = (qNum <= 1);
    if (nextBtn) nextBtn.disabled = (qNum >= totalQuestions);
    const currentQKey = qEl.querySelector('.choice-button').dataset.question;
    const buttons = qEl.querySelectorAll(`[data-question="${currentQKey}"]`);
    if (userAnswers[currentQKey]) {
        buttons.forEach(btn => {
            if (btn.dataset.value == userAnswers[currentQKey]) {
                btn.style.backgroundColor = 'var(--border-focus)';
                btn.style.color = 'var(--page-bg)';
            } else {
                btn.style.backgroundColor = 'var(--page-bg)';
                btn.style.color = 'var(--main-text)';
            }
        });
    } else {
        buttons.forEach(btn => {
            btn.style.backgroundColor = 'var(--page-bg)';
            btn.style.color = 'var(--main-text)';
        });
    }
}

function goToPrevQuestion() { if (currentQuestion > 1) { currentQuestion--; showQuestion(currentQuestion); } }
// [수정됨] '다음' 버튼 핸들러 (잠금 로직 적용)
function goToNextQuestion() {
    if (currentQuestion < totalQuestions) {
        currentQuestion++;
        showQuestion(currentQuestion);
    } else {
        // 마지막 단계에서 '결과 보기' 클릭 시
        const answeredCount = Object.keys(userAnswers).filter(k => k.startsWith('q')).length;
        
        if (answeredCount >= totalQuestions) {
            // [핵심] 설문 잠금 설정
            isSurveyLocked = true;
            
            calculateAndShowFinalResult();
            // 결과 보기 클릭 시, 이미지는 이미 로드되어 있으므로 패널만 전환
            activatePanel(document.getElementById('panel-sensitivity'));
        } else {
            alert("모든 문항에 답변해 주세요.");
        }
    }
}



// [수정됨] 답변 선택 시 처리 (이미지 교체 시 이전 이미지 저장 로직 추가)
function nextStep(questionName, value) {
    if (isSurveyLocked) return;

    userAnswers[questionName] = parseInt(value);

    // 버튼 스타일 업데이트
    const buttons = document.querySelectorAll(`[data-question="${questionName}"]`);
    buttons.forEach(btn => {
        const isSelected = (btn.dataset.value == value);
        btn.style.backgroundColor = isSelected ? 'var(--border-focus)' : 'transparent';
        btn.style.color = isSelected ? 'var(--page-bg)' : 'var(--main-text)';
    });

    const qNum = parseInt(questionName.replace('q', '').split('_')[0]);

    // [핵심] 6번 항목을 눌렀을 때
    if (qNum === totalQuestions) {
        // 이미 현재 보여지고 있는 이미지가 있다면, 그것을 '이전 이미지'로 백업
        if (currentEmotionImage) {
            prevEmotionImage = currentEmotionImage;
        } else {
            // 5번에서 갓 넘어와서 이미지가 없는 상태라면 이전 이미지는 없음
            prevEmotionImage = null;
        }
        
        // 애니메이션 리셋 (0부터 다시 시작)
        transitionProgress = 0; 

        // 새로운 결과 계산 및 로드
        calculateAndShowFinalResult();
        if (culturedCell && culturedCell.image_url && activeSketch) {
            activeSketch.loadImage(culturedCell.image_url, (img) => {
                currentEmotionImage = img;
            });
        }
    }
    
    visualizationState = qNum;

    if (qNum >= maxStepReached && qNum < totalQuestions) {
        maxStepReached = qNum + 1;
    } else if (qNum === totalQuestions) {
        maxStepReached = totalQuestions + 1;
    }

    updateNavButtons(qNum);
    
    const answeredCount = Object.keys(userAnswers).filter(k => k.startsWith('q')).length;
    if (progressBar) progressBar.style.width = (answeredCount / totalQuestions) * 100 + '%';
}

// [수정됨] 문항 이동 처리 (비선택 항목 투명 처리)
function showQuestion(qNum) {
    document.querySelectorAll('.question-step').forEach(q => q.style.display = 'none');
    const qEl = document.getElementById('q' + qNum);
    if (qEl) qEl.style.display = 'block';

    if (isSurveyLocked) {
        visualizationState = 6;
        transitionProgress = 1; 
        if (!currentEmotionImage) {
             calculateAndShowFinalResult();
             if (culturedCell && culturedCell.image_url && activeSketch) {
                activeSketch.loadImage(culturedCell.image_url, (img) => {
                    currentEmotionImage = img;
                });
            }
        }
    } else {
        if (qNum === totalQuestions) {
            visualizationState = 5;
            currentEmotionImage = null;
            transitionProgress = 0;
        } else {
            const isCurrentAnswered = Object.keys(userAnswers).some(k => k.startsWith(`q${qNum}_`));
            if (isCurrentAnswered) {
                visualizationState = qNum;
            } else {
                visualizationState = qNum - 1;
            }
            currentEmotionImage = null;
            transitionProgress = 0;
        }
    }

    if (progressText) progressText.textContent = `[ ${qNum} / ${totalQuestions} ]`;

    // 버튼 스타일 복구 시에도 투명 배경 적용
    const currentQKey = qEl.querySelector('.choice-button').dataset.question;
    const buttons = qEl.querySelectorAll(`[data-question="${currentQKey}"]`);
    
    buttons.forEach(btn => {
        // 잠금 상태 처리
        btn.disabled = isSurveyLocked;
        btn.style.cursor = isSurveyLocked ? 'not-allowed' : 'pointer';
        btn.style.opacity = isSurveyLocked ? '0.7' : '1';

        // 색상 처리 (선택 여부에 따라 투명/검정)
        if (userAnswers[currentQKey] && btn.dataset.value == userAnswers[currentQKey]) {
            btn.style.backgroundColor = 'var(--border-focus)';
            btn.style.color = 'var(--page-bg)';
        } else {
            // [수정] 기본 배경은 투명
            btn.style.backgroundColor = 'transparent';
            btn.style.color = 'var(--main-text)';
        }
    });

    updateNavButtons(qNum);
}




// 네비게이션 버튼 상태 업데이트 헬퍼 함수
function updateNavButtons(qNum) {
    const prevBtn = document.getElementById('prev-question');
    const nextBtn = document.getElementById('next-question');
    const qEl = document.getElementById('q' + qNum);
    
    if (prevBtn) prevBtn.disabled = (qNum <= 1);

    if (nextBtn) {
        const currentQKey = qEl.querySelector('.choice-button').dataset.question;
        const isAnswered = userAnswers.hasOwnProperty(currentQKey);

        if (qNum === totalQuestions) {
             nextBtn.textContent = isAnswered ? "[ 다음 ]" : "[ 완료 ]";
        } else {
             nextBtn.textContent = ">";
        }

        // 다음 버튼 활성화 조건: 이미 지난 단계 or 답변 완료
        // 단, 잠금 상태라면 무조건 다음으로 갈 수 있음 (결과 확인용)
        if (maxStepReached > qNum || isAnswered || isSurveyLocked) {
            nextBtn.disabled = false;
        } else {
            nextBtn.disabled = true;
        }
    }
}

function handleInjection() {
    sensitivitySlider.disabled = true;
    injectButton.disabled = true;
    injectButton.classList.add('injecting');
    finalInstability = sensitivitySlider.value / 5;
    if (activeSketch) activeSketch.noLoop();
    let progress = 0;
    const progressInterval = setInterval(() => {
        progress += 5;
        if (progress >= 100) {
            progress = 100;
            clearInterval(progressInterval);
            injectText.textContent = "[ 주입 완료 ]";
            injectProgressFill.style.width = '100%';
            setTimeout(() => {
                calculateAndShowFinalResult();
                activatePanel(document.getElementById('panel-result'));
            }, 500);
        }
        injectProgressFill.style.width = progress + '%';
        injectText.textContent = `[ 주입 중... ${progress}% ]`;
    }, 50);
}

function calculateAndShowFinalResult() {
    userScores = {
        vitality: (userAnswers['q1_vitality'] - 1) * 2.25 + 1,
        empathy: (userAnswers['q2_empathy'] - 1) * 2.25 + 1,
        self_assurance: (userAnswers['q3_self_assurance'] - 1) * 2.25 + 1,
        relationship_stability: (userAnswers['q4_relationship_stability'] - 1) * 2.25 + 1,
        emotion_control: (userAnswers['q5_emotion_control'] - 1) * 2.25 + 1,
        life_meaning: (userAnswers['q6_life_meaning'] - 1) * 2.25 + 1
    };
    culturedCell = findClosestEmotion(userScores);
}

function findClosestEmotion(scores) {
    let closestDist = Infinity;
    let closestEmotion = null;
    EMOTION_DATABASE.forEach(emotion => {
        const dist = Math.sqrt(
            Object.keys(scores).reduce((sum, key) => sum + Math.pow(scores[key] - emotion[key], 2), 0)
        );
        if (dist < closestDist) {
            closestDist = dist;
            closestEmotion = emotion;
        }
    });
    return closestEmotion;
}

function showResult(cell, scores) {
    if (!resultIdDisplay) return;
    resultIdDisplay.textContent = `[ ID: ${userAnswers['accessID']} ]`;
    if (resultCellNameDisplay) { const cellIndex = EMOTION_DATABASE.indexOf(cell); const label = `e-${(cellIndex + 1).toString().padStart(3, '0')}`; const engCellName = `${cell.eng_name} Cell`; resultCellNameDisplay.innerText = `${label} : ${cell.name} 세포 (${engCellName})`; }
    const displayOrder = [ { key: 'vitality', num: '①', name: '활력 (Vitality)' }, { key: 'life_meaning', num: '②', name: '삶의 의미 (Meaning)' }, { key: 'emotion_control', num: '③', name: '감정 통제 (Control)' }, { key: 'relationship_stability', num: '④', name: '관계 안정 (Relationship)' }, { key: 'self_assurance', num: '⑤', name: '자기 확신 (Self-Assurance)' }, { key: 'empathy', num: '⑥', name: '공감 (Empathy)' } ];
    if (resultAnalysisData) { let analysisHTML = '<h3 class="result-info-heading">[ 분석 데이터 (1-10 Scale) ]</h3>'; displayOrder.forEach(item => { analysisHTML += `<p><span class="font-thick">${item.num}</span> ${item.name}: ${scores[item.key].toFixed(1)} 점</p>`; }); resultAnalysisData.innerHTML = analysisHTML; }
    if (resultCellInfo) { resultCellInfo.innerHTML = ` <h3 class="result-info-heading">[ 1. 정의 (Definition) ]</h3><p>${cell.definition}</p> <h3 class="result-info-heading">[ 2. 발현 형태 (Manifestation) ]</h3><p>${cell.manifestation}</p> <h3 class="result-info-heading">[ 3. 잠재적 발전 (Potential) ]</h3><p>${cell.potential}</p> <h3 class="result-info-heading">[ 4. 관련 세포 (Related Cells) ]</h3><p>${cell.related_cells.join(', ')}</p>`; }
    const finalMessageEl = document.querySelector('.final-message');
    if(finalMessageEl && cell.commentary) { finalMessageEl.innerText = cell.commentary; }
    if (resultChart) { resultChart.destroy(); }
    const chartLabels = ['1', '2', '3', '4', '5', '6'];
    const chartData = [ scores.vitality, scores.life_meaning, scores.emotion_control, scores.relationship_stability, scores.self_assurance, scores.empathy ].map(s => parseFloat(s.toFixed(1)));
    const pointLabelsInsidePlugin = { id: 'pointLabelsInside', afterDraw: (chart) => { const ctx = chart.ctx; ctx.save(); ctx.font = '900 18px OnulDamso'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; chart.getDatasetMeta(0).data.forEach((p, i) => { const label = chart.data.labels[i]; ctx.fillText(label, p.x, p.y + 1); }); ctx.restore(); } };
    resultChart = new Chart(chartCanvas, { type: 'line', data: { labels: chartLabels, datasets: [{ data: chartData, borderColor: 'rgba(0, 0, 0, 1)', borderWidth: 2, pointBackgroundColor: '#000', pointRadius: 12, pointHoverRadius: 12, tension: 0.1 }] }, options: { maintainAspectRatio: false, animation: { duration: 0 }, scales: { x: { display: false }, y: { display: false, min: -2, max: 12 } }, plugins: { legend: { display: false }, tooltip: { enabled: false }, } }, plugins: [pointLabelsInsidePlugin] });
}

// --- 영수증 출력 로직 (기존과 동일) ---
let receiptEscPosDataCache = null;
function bytesToHexString(bytes) { return Array.from(bytes, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join(''); }
function convertCanvasToEscPos(canvas, maxWidth = 384) { const scale = maxWidth / canvas.width; const newWidth = maxWidth; const newHeight = Math.floor(canvas.height * scale); const tempCanvas = document.createElement('canvas'); tempCanvas.width = newWidth; tempCanvas.height = newHeight; const ctx = tempCanvas.getContext('2d'); ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, newWidth, newHeight); ctx.drawImage(canvas, 0, 0, newWidth, newHeight); const imageData = ctx.getImageData(0, 0, newWidth, newHeight); const pixels = imageData.data; const contrast = 150; const factor = (259 * (contrast + 255)) / (255 * (259 - contrast)); for (let i = 0; i < pixels.length; i += 4) { pixels[i] = factor * (pixels[i] - 128) + 128; pixels[i+1] = factor * (pixels[i+1] - 128) + 128; pixels[i+2] = factor * (pixels[i+2] - 128) + 128; } ctx.putImageData(imageData, 0, 0); const ditheredData = ctx.getImageData(0, 0, newWidth, newHeight); const monoData = new Uint8Array(newWidth * newHeight); const grayData = []; for (let i = 0; i < ditheredData.data.length; i += 4) { const gray = (ditheredData.data[i] * 0.299 + ditheredData.data[i + 1] * 0.587 + ditheredData.data[i + 2] * 0.114); grayData.push(gray); } for (let y = 0; y < newHeight; y++) { for (let x = 0; x < newWidth; x++) { const index = y * newWidth + x; const newPixel = grayData[index] < 128 ? 0 : 255; monoData[index] = newPixel / 255; const quantError = grayData[index] - newPixel; if (x + 1 < newWidth) grayData[index + 1] += quantError * 7 / 16; if (y + 1 < newHeight) { if (x > 0) grayData[index - 1 + newWidth] += quantError * 3 / 16; grayData[index + newWidth] += quantError * 5 / 16; if (x + 1 < newWidth) grayData[index + 1 + newWidth] += quantError * 1 / 16; } } } const bytes = []; const command = [0x1d, 0x76, 0x30, 0x00]; const xL = (newWidth / 8) & 0xFF; const xH = 0x00; const yL = newHeight & 0xFF; const yH = (newHeight >> 8) & 0xFF; bytes.push(...command, xL, xH, yL, yH); for (let i = 0; i < newHeight; i++) { for (let j = 0; j < newWidth / 8; j++) { let byte = 0; for (let k = 0; k < 8; k++) { if (monoData[i * newWidth + (j * 8 + k)] === 0) { byte |= (1 << (7 - k)); } } bytes.push(byte); } } return new Uint8Array(bytes); }
async function handlePrint() {
    const printButton = document.getElementById('print-button');
    if (!window.qz) {
        alert("필수 라이브러리를 찾을 수 없습니다.");
        return;
    }

    printButton.disabled = true;
    printButton.textContent = '[ 프린터 연결 중... ]';

    try {
        await qz.websocket.connect();
        
        let escposData;

        // 캐시 기능을 다시 활성화하여 두 번째 인쇄부터는 빠르게 실행되도록 합니다.
        if (receiptEscPosDataCache) {
            console.log("캐시된 프린터 데이터를 사용합니다.");
            escposData = receiptEscPosDataCache;
        } else {
            console.log("새로운 프린터 데이터를 생성합니다. 웹 폰트 로딩을 기다립니다...");
            printButton.textContent = '[ 영수증 이미지 생성 중... ]';

            await document.fonts.ready;
            
            // 폰트가 렌더링될 최소한의 시간을 보장합니다.
            await new Promise(resolve => setTimeout(resolve, 300));

            const p5Canvas = document.getElementById('p5-result-canvas');
            if (!p5Canvas) throw new Error("세포 이미지가 올바르게 생성되지 않았습니다.");
            const p5ImageData = p5Canvas.toDataURL('image/png');
            
            if (!resultChart || !resultChart.ctx) throw new Error("결과 차트가 올바르게 생성되지 않았습니다.");
            const chartImageData = resultChart.toBase64Image('image/png');

            if (!logoImageDataURLCache) {
                const svgElement = document.getElementById('main-logo');
                const svgString = new XMLSerializer().serializeToString(svgElement);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const image = new Image();
                image.src = url;
                logoImageDataURLCache = await new Promise((resolve, reject) => {
                    image.onload = () => {
                        const c = document.createElement('canvas');
                        c.width = image.width; c.height = image.height;
                        c.getContext('2d').drawImage(image, 0, 0);
                        URL.revokeObjectURL(url);
                        resolve(c.toDataURL('image/png'));
                    };
                    image.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
                });
            }
            
            const cellIndex = EMOTION_DATABASE.indexOf(culturedCell);
            const cellCode = `E-${(cellIndex + 1).toString().padStart(3, '0')}`;
            const cellNames = `${culturedCell.eng_name.toUpperCase()} (${culturedCell.name})`;
            let cellType = 'TYPE A';
            if (['희열', '무기력', '기대'].includes(culturedCell.name)) cellType = 'TYPE B';
            else if (['조급', '공감', '배신', '답답'].includes(culturedCell.name)) cellType = 'TYPE C';
            else if (['냉소', '만족', '자책', '기쁨', '위축', '허무', '자부심', '흐뭇함'].includes(culturedCell.name)) cellType = 'TYPE D';
            const displayOrder = [
                { key: 'vitality', num: '1', name: '활력' }, { key: 'life_meaning', num: '2', name: '삶의 의미' },
                { key: 'emotion_control', num: '3', name: '감정 통제' }, { key: 'relationship_stability', num: '4', name: '관계 안정' },
                { key: 'self_assurance', num: '5', name: '자기 확신' }, { key: 'empathy', num: '6', name: '공감' }
            ];
            let receiptAnalysisHTML = '';
            displayOrder.forEach(item => {
                receiptAnalysisHTML += `<div style="display: flex; align-items: baseline; line-height: 1.6; font-size: 14px;"><span style="display: flex; align-items: center; white-space: nowrap;"><span style="font-weight: 900; display: inline-flex; justify-content: center; align-items: center; width: 14px; height: 14px; background-color: #000; color: #fff; border-radius: 50%; font-size: 10px; margin-right: 5px; line-height: 1; position: relative; top: -1px;">${item.num}</span>${item.name}</span><span style="flex-grow: 1; border-bottom: 1px dotted #000; margin: 0 5px;"></span><span style="font-weight: 400;">${userScores[item.key].toFixed(1)}</span></div>`;
            });
            const printContainer = document.createElement('div');
            printContainer.style.position = "absolute"; printContainer.style.left = "-2000px"; printContainer.style.background = "#FFF";
            printContainer.style.width = "384px"; printContainer.style.fontFamily = "'OnulDamso', 'D2Coding', monospace";
            printContainer.style.fontWeight = "400"; printContainer.style.color = "#000";
            printContainer.style.padding = "30px 15px 20px 15px"; printContainer.style.boxSizing = "border-box";
            printContainer.innerHTML = `
                <style> @font-face { font-family: 'OnulDamso'; font-weight: 400; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Regular.woff2') format('woff2'); } @font-face { font-family: 'OnulDamso'; font-weight: 900; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302-01@1.0/OnulDamso-Heavy.woff2') format('woff2'); } </style>
                <div style="text-align: center; margin-bottom: 25px;"> <img src="${logoImageDataURLCache}" style="width: 180px;" /> </div>
                <div style="font-size: 15px; margin-bottom: 10px; font-weight: 400;">[ ID: ${userAnswers.accessID} ]</div>
                <div style="border: 1px solid #000; padding: 10px; margin-bottom: 8px; width: 100%; aspect-ratio: 1 / 1; display: flex; justify-content: center; align-items: center;"> <img src="${p5ImageData}" style="max-width: 90%; max-height: 90%;" /> </div>
                
                <!-- [최종 수정] 전체 div에서 font-weight를 빼고, 가운데 span에만 font-weight: 900을 추가합니다. -->
                <div style="display: flex; justify-content: space-between; font-size: 15px; margin-bottom: 15px;"> <span>${cellCode}</span> <span style="letter-spacing: 0.5px; font-weight: 900;">${cellNames}</span> <span>${cellType}</span> </div>
                
                <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; letter-spacing: 0.5px; margin: 15px 0 8px 0; padding: 5px 0; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">RESULT SHEET</div>
                <div style="width: 100%; text-align: center; margin: 20px 0;"> <img src="${chartImageData}" style="width: 100%; height: auto;" /> </div>
                <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; white-space: nowrap; padding: 5px 0; margin-top: 15px; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">[ 분석 데이터 (10 MAX) ]</div>
                <div style="margin-top: 10px; display: flex; flex-direction: column; gap: 5px;"> ${receiptAnalysisHTML} </div>
                <div style="margin-top: 15px;"> <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; margin-bottom: 5px; padding: 5px 0; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">정의 [ Definition ]</div> <div style="font-size: 14px; line-height: 1.4; font-weight: 400;">${culturedCell.definition}</div> </div>
                <div style="margin-top: 15px;"> <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; margin-bottom: 5px; padding: 5px 0; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">발현 형태 [ Manifestation ]</div> <div style="font-size: 14px; line-height: 1.4; font-weight: 400;">${culturedCell.manifestation}</div> </div>
                <div style="margin-top: 15px;"> <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; margin-bottom: 5px; padding: 5px 0; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">잠재적 발전 [ Potential ]</div> <div style="font-size: 14px; line-height: 1.4; font-weight: 400;">${culturedCell.potential}</div> </div>
                <div style="margin-top: 15px;"> <div style="font-family: 'OnulDamso', monospace; font-weight: 400; font-size: 15px; margin-bottom: 5px; padding: 5px 0; border-top: 1px solid #000; border-bottom: 1px solid #000; text-align: center;">관련 세포 [ Related cells ]</div> <div style="font-size: 14px; line-height: 1.4; font-weight: 400;">${culturedCell.related_cells.join(', ')}</div> </div>
                <div style="border-top: 1px solid #000; margin: 20px 0;"></div>
                <div style="text-align: center; font-size: 15px; margin-bottom: 10px;"> ${culturedCell.commentary} </div>
                <div style="text-align: center; font-size: 12px; font-weight: 900; opacity: 0.8;"> Copyright © 2025 E.C.A. Records </div>
            `;
            document.body.appendChild(printContainer);
            const canvas = await html2canvas(printContainer, { scale: 3, useCORS: true });
            document.body.removeChild(printContainer);
            
            const convertedData = convertCanvasToEscPos(canvas);
            
            receiptEscPosDataCache = convertedData;
            escposData = convertedData;
        }

        // --- 수정 시작: 안전 패딩(Buffer Padding)을 포함한 통합 전송 ---
        
        const printerName = await qz.printers.getDefault();
        const config = qz.configs.create(printerName);

        // 1. 바이너리 데이터 준비
        // 초기화 명령 (ESC @)
        const initCmd = new Uint8Array([0x1B, 0x40]);
        
        // [핵심 해결책] 안전 패딩 (Safety Padding)
        // 초기화 직후 프린터가 안정화될 때까지 의미 없는 0x00(Null) 데이터를 흘려보냅니다.
        // 앞부분 데이터가 씹히더라도 이 0x00 구간에서 소모되므로, 뒤따라오는 이미지는 안전합니다.
        const paddingSize = 100; 
        const safetyPadding = new Uint8Array(paddingSize).fill(0x00);

        // 종료 명령: 여백 5줄 + 커팅 (ESC d 5 + GS V A 0)
        const endCmd = new Uint8Array([0x1B, 0x64, 0x05, 0x1D, 0x56, 0x41, 0x00]); 

        // 2. [초기화 + 안전패딩 + 이미지 + 커팅]을 하나의 배열로 병합
        const combinedData = new Uint8Array(initCmd.length + safetyPadding.length + escposData.length + endCmd.length);
        
        let offset = 0;
        combinedData.set(initCmd, offset); offset += initCmd.length;
        combinedData.set(safetyPadding, offset); offset += safetyPadding.length; // 패딩 삽입
        combinedData.set(escposData, offset); offset += escposData.length;
        combinedData.set(endCmd, offset);

        // 3. Hex 문자열 변환
        const fullHexString = bytesToHexString(combinedData);

        // 4. 500ms의 강제 대기 (페이지 로드 직후 소켓 안정화 시간 확보)
        if (printButton.textContent !== '[ 전송 완료 ]') {
             await new Promise(resolve => setTimeout(resolve, 500));
        }

        // 5. 전송
        const finalCommand = [
            { type: 'raw', format: 'hex', data: fullHexString }
        ];

        printButton.textContent = '[ 프린터로 전송 중... ]';
        await qz.print(config, finalCommand);
        
        // --- 수정 끝 ---
        
        alert(`'${printerName}' 프린터로 영수증을 전송했습니다.`);
        printButton.textContent = '[ 전송 완료 ]';

    } catch (err) {
        console.error("인쇄 중 오류:", err);
        alert("인쇄 중 오류가 발생했습니다: " + err.message);
        receiptEscPosDataCache = null;
    } finally {
        if (qz.websocket.isActive()) {
            await qz.websocket.disconnect();
        }
        setTimeout(() => {
             printButton.disabled = false;
             printButton.textContent = '[ 영수증 출력하기 ]';
        }, 1500);
    }
}
function activatePanel(panel) {
    if (activeSketch) {
        activeSketch.remove();
        activeSketch = null;
    }
    const panelId = panel.id.split('-')[1];
    body.className = `main-active ${panelId}-active`;
    activePanelId = panel.id;
    contentBlocks.forEach(cb => cb.classList.remove('active'));
    const targetContent = document.getElementById(`content-${panelId}`);
    if (targetContent) targetContent.classList.add('active');

    rebindDOM();

    if (panelId === 'survey') {
        initStep2Sketch();
        showQuestion(currentQuestion);
    } else if (panelId === 'sensitivity') {
        initStep3Sketch();
    } else if (panelId === 'result') {
        if (culturedCell && userScores) {
            showResult(culturedCell, userScores);
            initStep4Sketch();
        }
    }
}

// --- p5.js 그리기 헬퍼 ---
function drawCellHelper(pg, cx, cy, radius, instability, bodyColor, nucleusColor) {
    pg.noStroke();
    pg.fill(bodyColor[0], bodyColor[1], bodyColor[2]);
    pg.push();
    pg.translate(cx, cy);
    pg.beginShape();
    for (let a = 0; a < pg.TWO_PI; a += 0.1) {
        let r = radius + pg.map(pg.noise(a * 1.5, noiseOffset), 0, 1, -instability, instability);
        pg.vertex(r * pg.cos(a), r * pg.sin(a));
    }
    pg.endShape(pg.CLOSE);
    if (nucleusColor) {
        pg.fill(nucleusColor[0], nucleusColor[1], nucleusColor[2]);
        pg.beginShape();
        for (let a = 0; a < pg.TWO_PI; a += 0.2) {
            let r = radius * 0.6 + pg.map(pg.noise(a, nucleusNoiseOffset), 0, 1, -instability * 0.5, instability * 0.5);
            pg.vertex(r * pg.cos(a), r * pg.sin(a));
        }
        pg.endShape(pg.CLOSE);
    }
    pg.pop();
    noiseOffset += 0.02;
    nucleusNoiseOffset += 0.01;
}

// --- 이미지 왜곡 그리기 헬퍼 (최종 수정) ---
function drawDistortedImage(p, pg, img, instability, targetDiameter) {
    if (!img || !img.width || !img.height) return;
    pg.clear();
    
    // 화질 개선 (step: 2)
    const step = 1.5;
    // 버퍼의 중앙에 targetDiameter 크기의 이미지를 그리기 위한 여백 계산
    const padding = (pg.width - targetDiameter) / 2;

    for (let y = 0; y < targetDiameter; y += step) {
        for (let x = 0; x < targetDiameter; x += step) {
            // 원본 이미지 좌표와 1:1로 매핑
            const mapX = p.map(x, 0, targetDiameter, 0, img.width);
            const mapY = p.map(y, 0, targetDiameter, 0, img.height);
            
            const noiseVal = p.noise(mapX * 0.01, mapY * 0.01, noiseOffset);
            const offset = p.map(noiseVal, 0, 1, -instability, instability);

            const srcX = p.constrain(p.floor(mapX + offset), 0, img.width - 1);
            const srcY = p.constrain(p.floor(mapY + offset), 0, img.height - 1);
            
            const col = img.get(srcX, srcY);
            if (p.alpha(col) > 100) {
                pg.fill(col);
                // 버퍼의 중앙 영역에 그리도록 padding 값을 더해줌
                pg.rect(x + padding, y + padding, step, step);
            }
        }
    }
    noiseOffset += 0.03; 
}

// --- p5.js 스케치 인스턴스 ---

// [최종 수정] P5.js 스케치 (2단계: 뭉침과 성장이 동시에 일어나도록 수정)
function initStep2Sketch() {
    let particles = [];
    let mergedCellPos, mergedCellVel;
    const sketch = p => {
        let parentContainer, offscreenBuffer;
        let nucleusColorOffset = Math.random() * 100;
        let bodyColorOffset = Math.random() * 200;
        
        let step2Growth = 0; // 2단계 세포 성장 변수

        class Particle { 
            constructor() { 
                this.pos = p.createVector(p.random(p.width), p.random(p.height)); 
                this.vel = p5.Vector.random2D().mult(p.random(0.5, 1.2)); 
                this.radius = 8; 
                this.merged = false; 
            } 
            update(bounds) { 
                if (this.merged) return; 
                this.pos.add(this.vel); 
                if (this.pos.x < this.radius || this.pos.x > bounds.width - this.radius) { 
                    this.vel.x *= -1; 
                    this.pos.x = p.constrain(this.pos.x, this.radius, bounds.width - this.radius); 
                } 
                if (this.pos.y < this.radius || this.pos.y > bounds.height - this.radius) { 
                    this.vel.y *= -1; 
                    this.pos.y = p.constrain(this.pos.y, this.radius, bounds.height - this.radius); 
                } 
            } 
            moveTo(target) { 
                let force = p5.Vector.sub(target, this.pos); 
                if (force.mag() < 10) { this.merged = true; } 
                
                // 뭉치는 속도 (빠르게)
                force.setMag(p.max(force.mag() * 0.08, 3)); 
                
                this.pos.add(force); 
            } 
            display() { 
                if (this.merged) return; 
                p.noStroke(); 
                p.fill(30); 
                p.circle(this.pos.x, this.pos.y, this.radius * 2); 
            } 
        }
        
        p.setup = () => { 
            parentContainer = document.getElementById('content-survey'); 
            let c = p.createCanvas(parentContainer.offsetWidth, parentContainer.offsetHeight).parent(parentContainer); 
            c.addClass('background-canvas'); 
            
            mergedCellPos = lastCellPos ? lastCellPos.copy() : p.createVector(p.width / 2, p.height / 2);
            mergedCellVel = lastCellVel ? lastCellVel.copy() : p5.Vector.random2D().mult(1.5);
            
            const bufferPadding = 250;
            const bufferSize = CELL_DIAMETER + bufferPadding;
            offscreenBuffer = p.createGraphics(bufferSize, bufferSize);
            offscreenBuffer.noStroke();
        };

        p.draw = () => {
            p.clear();

            if (visualizationState === 0) return;

            // 공통: 세포 위치 업데이트
            const radius = CELL_DIAMETER / 2;
            mergedCellPos.add(mergedCellVel);
            if (mergedCellPos.x < radius || mergedCellPos.x > p.width - radius) { 
                mergedCellPos.x = p.constrain(mergedCellPos.x, radius, p.width - radius);
                mergedCellVel.x *= -1; 
            }
            if (mergedCellPos.y < radius || mergedCellPos.y > p.height - radius) { 
                mergedCellPos.y = p.constrain(mergedCellPos.y, radius, p.height - radius);
                mergedCellVel.y *= -1; 
            }
            lastCellPos = mergedCellPos.copy();
            lastCellVel = mergedCellVel.copy();

            // 2단계가 아니면 성장 변수 초기화
            if (visualizationState !== 2) {
                step2Growth = 0;
            }

            // 6단계 애니메이션 및 이미지 처리
            if (isSurveyLocked || (visualizationState === 6 && currentEmotionImage)) {
                if (transitionProgress < 1) {
                    transitionProgress += 0.15; 
                    if (transitionProgress > 1) transitionProgress = 1;
                }
                
                if (transitionProgress < 1) {
                    let shrinkScale = 1 - transitionProgress;
                    p.push();
                    p.translate(mergedCellPos.x, mergedCellPos.y);
                    p.scale(shrinkScale); 
                    
                    if (prevEmotionImage) {
                        p.imageMode(p.CENTER);
                        p.image(prevEmotionImage, 0, 0, CELL_DIAMETER, CELL_DIAMETER);
                    } else {
                        p.translate(-mergedCellPos.x, -mergedCellPos.y);
                        drawCellBody(p, mergedCellPos, radius);
                    }
                    p.pop();
                }

                if (currentEmotionImage) {
                    let growScale = transitionProgress;
                    p.push();
                    p.translate(mergedCellPos.x, mergedCellPos.y);
                    p.scale(growScale);
                    drawDistortedImage(p, offscreenBuffer, currentEmotionImage, 10, CELL_DIAMETER);
                    p.imageMode(p.CENTER);
                    p.image(offscreenBuffer, 0, 0);
                    p.pop();
                } else {
                     if (transitionProgress >= 1 && !prevEmotionImage) drawCellBody(p, mergedCellPos, radius);
                }
                return;
            }

            // 3~5단계: 세포 형태
            if (visualizationState >= 3) {
                particles.forEach(pt => { pt.merged = true; });
                drawCellBody(p, mergedCellPos, radius);
            }
            // 2단계: 파티클 뭉침 + 동시 성장
            else if (visualizationState === 2) {
                // 1. 파티클 이동 (계속 뭉치게 함)
                particles.forEach(pt => pt.moveTo(mergedCellPos));
                
                // 2. 세포 성장 (파티클이 뭉치는 동안 계속 커짐)
                if (step2Growth < 1) {
                    step2Growth += 0.04; // 성장 속도 (0.04 -> 약 25프레임만에 커짐, 파티클 속도와 얼추 맞춤)
                    if (step2Growth > 1) step2Growth = 1;
                }

                // 3. 커지는 세포 그리기
                // 60(최종 크기) * step2Growth
                if (step2Growth > 0) {
                    drawCellHelper(p, mergedCellPos.x, mergedCellPos.y, 60 * step2Growth, 10, finalCellBodyColor, null);
                }

                // 4. 아직 안 뭉친 파티클 그리기 (세포 위나 아래에 표시 - 여기선 덮어씌워지도록 아래에 배치했으나 draw 순서상 위)
                particles.forEach(pt => {
                    if (!pt.merged) pt.display();
                });
            }
            // 1단계: 파티클 흩어짐
            else if (visualizationState === 1) {
                if (particles.length < 15) { particles.push(new Particle()); }
                particles.forEach(pt => { 
                    pt.merged = false; 
                    pt.update({ width: p.width, height: p.height }); 
                    pt.display(); 
                });
            }
        };

        function drawCellBody(p, pos, radius) {
            let currentInstability = 10 + (5 - (userAnswers['q3_self_assurance'] || 3)) * 3;
            let animatedBodyColor = finalCellBodyColor;
            let animatedNucleusColor = finalNucleusColor;

            if (visualizationState >= 4) {
                p.colorMode(p.HSB);
                let hue = p.map(p.noise(bodyColorOffset), 0, 1, 0, 360);
                animatedBodyColor = p.color(hue, 70, 90).levels.slice(0, 3);
                bodyColorOffset += 0.01;
                p.colorMode(p.RGB);
            }

            if (visualizationState >= 5) {
                p.colorMode(p.HSB);
                let hue = p.map(p.noise(nucleusColorOffset), 0, 1, 0, 360);
                animatedNucleusColor = p.color(hue, 80, 100).levels.slice(0, 3);
                nucleusColorOffset += 0.015;
                p.colorMode(p.RGB);
            }
            
            drawCellHelper(p, pos.x, pos.y, radius, currentInstability, animatedBodyColor, animatedNucleusColor);
        }

        p.windowResized = () => p.resizeCanvas(parentContainer.offsetWidth, parentContainer.offsetHeight);
    };
    activeSketch = new p5(sketch);
}

// --- 민감도 설정 스케치 (수정됨) ---
function initStep3Sketch() {
    const sketch = p => {
        let parentContainer, offscreenBuffer, pos, vel;
        const bufferPadding = 200; // 잘림 방지 여유 공간
        const bufferSize = CELL_DIAMETER + bufferPadding;

        p.setup = () => {
            parentContainer = document.getElementById('content-sensitivity');
            let c = p.createCanvas(parentContainer.offsetWidth, parentContainer.offsetHeight).parent(parentContainer);
            c.addClass('background-canvas');
            
            offscreenBuffer = p.createGraphics(bufferSize, bufferSize);
            offscreenBuffer.noStroke();

            pos = lastCellPos ? lastCellPos.copy() : p.createVector(p.width / 2, p.height / 2);
            vel = lastCellVel ? lastCellVel.copy() : p5.Vector.random2D().mult(1.5);
        };

        p.draw = () => {
            if (currentEmotionImage) {
                let instability = sensitivitySlider.value / 5;
                drawDistortedImage(p, offscreenBuffer, currentEmotionImage, instability, CELL_DIAMETER);
            } else {
                offscreenBuffer.clear();
                drawCellHelper(offscreenBuffer, bufferSize / 2, bufferSize / 2, CELL_DIAMETER / 2, 5 + (sensitivitySlider.value / 100) * 30, finalCellBodyColor, finalNucleusColor);
            }
            
            p.clear();
            
            const radius = CELL_DIAMETER / 2; // 충돌 반경은 실제 세포 크기 기준
            pos.add(vel);
            if (pos.x < radius || pos.x > p.width - radius) { vel.x *= -1; }
            if (pos.y < radius || pos.y > p.height - radius) { vel.y *= -1; }
            
            lastCellPos = pos.copy();
            lastCellVel = vel.copy();
            
            p.imageMode(p.CENTER);
            p.image(offscreenBuffer, pos.x, pos.y);
        };
        
        p.windowResized = () => p.resizeCanvas(parentContainer.offsetWidth, parentContainer.offsetHeight);
    };
    activeSketch = new p5(sketch);
}

// --- 결과 화면 스케치 (최종 수정) ---
function initStep4Sketch() {
    const sketch = p => {
        let scrollContainer, contentContainer, pos, offscreenBuffer;
        const easing = 0.05, scrollSpeed = 5, scrollZone = 70;
        
        // 결과 화면의 세포 크기와 버퍼 크기 설정
        const targetDiameter = 160;
        const bufferPadding = 200; // 넉넉한 여유 공간
        const bufferSize = targetDiameter + bufferPadding;

        p.setup = () => {
            scrollContainer = document.getElementById('step4-result');
            contentContainer = document.getElementById('result-page-container');
            let c = p.createCanvas(250, 250).parent(contentContainer);
            c.id('p5-result-canvas');
            c.style('position', 'absolute');
            c.style('z-index', '-1');
            pos = p.createVector((contentContainer.clientWidth - p.width) / 2, (contentContainer.clientHeight - p.height) / 2);
            
            offscreenBuffer = p.createGraphics(bufferSize, bufferSize);
            offscreenBuffer.noStroke();
        };

        p.draw = () => {
            if (currentEmotionImage) {
                drawDistortedImage(p, offscreenBuffer, currentEmotionImage, finalInstability, targetDiameter);
            } else {
                 offscreenBuffer.clear();
                 drawCellHelper(offscreenBuffer, bufferSize / 2, bufferSize / 2, targetDiameter / 2, finalInstability, finalCellBodyColor, finalNucleusColor);
            }
            
            p.clear();
            p.imageMode(p.CENTER); // CENTER 모드로 캔버스 중앙에 버퍼를 그림
            p.image(offscreenBuffer, p.width / 2, p.height / 2);

            // 기존 마우스 추적 및 스크롤 로직
            const scrollBounds = scrollContainer.getBoundingClientRect();
            if (p.winMouseY < scrollBounds.top + scrollZone) { scrollContainer.scrollTop -= scrollSpeed; }
            const isAtBottom = scrollContainer.scrollTop + scrollContainer.clientHeight + 1 >= scrollContainer.scrollHeight;
            if (p.winMouseY > scrollBounds.bottom - scrollZone && !isAtBottom) { scrollContainer.scrollTop += scrollSpeed; }
            let targetX = p.winMouseX - scrollBounds.left - p.width / 2;
            let targetY = p.winMouseY - scrollBounds.top + scrollContainer.scrollTop - p.height / 2;
            pos.x += (targetX - pos.x) * easing;
            pos.y += (targetY - pos.y) * easing;
            pos.x = p.constrain(pos.x, 0, scrollContainer.clientWidth - p.width);
            pos.y = p.constrain(pos.y, 0, scrollContainer.scrollHeight - p.height);
            p.canvas.style.left = `${pos.x}px`;
            p.canvas.style.top = `${pos.y}px`;
        };
        p.windowResized = () => {
            const scrollBounds = scrollContainer.getBoundingClientRect();
            if (pos.x + p.width > scrollBounds.width) { pos.x = scrollBounds.width - p.width; }
            if (pos.y + p.height > scrollContainer.scrollHeight) { pos.y = scrollContainer.scrollHeight - p.height; }
        }
    };
    activeSketch = new p5(sketch);
}

// --- 전역 이벤트 리스너 (수정됨: 설문 완료 전 탭 이동 차단) ---
document.addEventListener('DOMContentLoaded', () => {
    accessButton = document.getElementById('access-button');
    guestInput = document.getElementById('guest-id');
    terminalOutput = document.getElementById('terminal-output');
    accessButton.addEventListener('click', handleAccess);
    guestInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleAccess());

    panels.forEach(panel => {
        panel.addEventListener('click', () => {
            // [핵심 수정] 설문이 완료(잠금)되지 않았다면 탭 이동 불가능
            if (!isSurveyLocked) {
                // 필요하다면 여기에 alert("설문을 먼저 완료해주세요."); 등을 넣을 수 있습니다.
                return; 
            }

            // 설문이 완료된 이후에는 결과 탭 접근 제어 로직 유지
            // (주입이 완료되어 결과가 나와야만 결과 탭 접근 가능)
            if (panel.id === 'panel-result' && (!culturedCell || !userScores)) return;
            
            // 탭 이동 실행
            if (panel.id !== activePanelId) activatePanel(panel);
        });
    });
});
</script>
</body>
</html>
